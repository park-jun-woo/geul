---
title: "Почему эмбеддинг-векторов недостаточно"
weight: 11
date: 2026-02-26T12:00:18+09:00
lastmod: 2026-02-26T12:00:18+09:00
tags: ["эмбеддинг", "вектор", "белый ящик"]
summary: "Перестановка эмбеддинг-векторов ломает модель. Чтобы избежать поломки, нужно перестроить модель с нуля. Нужна не прозрачность внутри чёрного ящика, а прозрачный слой снаружи."
author: "Junwoo Park"
authorLink: "https://parkjunwoo.com/1/about"
image: "/images/og-default.webp"
---

## Векторы хороши для вычислений, но не поддаются интерпретации. Сделать внутренности чёрного ящика прозрачными невозможно.

---

## Эмбеддинг-векторы — замечательная технология

«Король - Мужчина + Женщина = Королева.»

Когда word2vec продемонстрировал это, мир был поражён.
Представьте слова как векторы в сотнях измерений,
и семантические отношения проявятся как векторные операции.

Эмбеддинг-векторы — основа LLM.
Всё в трансформере — это векторные вычисления.
Токены становятся векторами.
Механизм внимания вычисляет сходство между векторами.
Выходные данные преобразуются из векторов обратно в токены.

Близкие значения — близкие векторы.
Разные значения — далёкие векторы.
Поиск — вычисление векторного сходства.
Классификация — установление границ в векторном пространстве.

Без эмбеддинг-векторов нынешнего ИИ не существовало бы.

Так почему бы не использовать эмбеддинг-векторы для представления знаний?
Выровнять их напрямую, структурировать, сделать интерпретируемыми.

Не получится.
Самый верный способ убедиться в этом — попробовать.

---

## AILEV: мы попробовали

Проект GEUL изначально начинался под названием AILEV.

AI Language Embedding Vector.

Само название провозглашало цель:
язык ИИ, напрямую оперирующий эмбеддинг-векторами.

Замысел был таким:

Представить значение 512-мерным вектором.
Назначить роли сегментам вектора.
Первые 128 измерений — для сущностей, следующие 128 — для отношений, следующие 128 — для свойств, остальное — для метаданных.
Подобно тому как RGBA разлагает цвет на четыре канала, разложить значение на размерностные сегменты.

Обучить BERT преобразовывать естественный язык в эти структурированные векторы.
При вводе «Сеул — столица Кореи»
сегмент сущностей выдаёт вектор Сеула, сегмент отношений — вектор столицы, сегмент свойств — вектор Кореи.

Раз это векторы, вычисления возможны.
Поиск по сходству возможен.
Сокращение размерности обеспечивает изящную деградацию.
С 512 до 256 измерений — точность падает, но ключевой смысл сохраняется.

Было элегантно. В теории.

---

## Почему это не работает

### Произвольная перестановка векторов ломает модель

Эмбеддинг-векторы LLM — результат обучения.

Прочитав миллиарды текстов,
модель самостоятельно оптимизирует свои внутренние представления.
Что означает каждое измерение — решила модель.
Не человек.

Что произойдёт, если объявить «первые 128 измерений — для сущностей»?

В векторном пространстве, которое выучила модель,
информация о сущностях не располагается в первых 128 измерениях.
Она распределена по всем 768 измерениям.
Информация об отношениях, свойствах, временных формах — всё перемешано.

Это не ошибка проектирования, а природа обучения.
Обратное распространение ошибки (backpropagation) находит
расположение векторов, оптимальное для задачи.
Не расположение, которое можно интерпретировать.
Оптимальное и интерпретируемое — не одно и то же.

Если принудительно переставить векторы — «сущности здесь, отношения там» —
статистические связи, которые модель усвоила, разрушаются.
Производительность падает.

### Перестановка без поломки означает пересоздание модели

Тогда почему бы не обучить с нуля с ограничением «первые 128 измерений — для сущностей»?

Можно. В теории.
Но это не выравнивание эмбеддинг-векторов.
Это проектирование новой архитектуры модели.

Нужны обучающие данные. Миллиарды токенов.
Нужна инфраструктура. Тысячи GPU.
Нужно время. Месяцы.
И нет гарантии, что полученная модель будет работать так же хорошо, как существующие LLM.

Усилия слишком велики.

Задача «выровнять векторы, чтобы сделать их интерпретируемыми»
превратилась в «пересоздать LLM с нуля».
Это не решение проблемы, а её расширение.

### Интерпретация невозможна

Допустим, удалось создать структурированный вектор.
512-мерный вектор.
Пусть первые 128 измерений — для сущностей.

Значения сегмента сущностей: `[0.23, -0.47, 0.81, 0.12, ...]`.

Как узнать, это «Samsung Electronics» или «Hyundai Motor»?

Нужно найти ближайший вектор.
Нужно вычислить сходство в векторной базе данных.
И получить вероятностный ответ: «вероятно, Samsung Electronics».

«Вероятно.»

Векторы по своей природе непрерывны.
Между векторами Samsung Electronics и SK Hynix
существует бесконечно много промежуточных векторов.
Что означают эти промежуточные векторы — не знает никто.

Это не техническое ограничение, а математическая истина.
Представление дискретных значений в непрерывном пространстве
размывает границы.
Неоднозначность была [проблемой естественного языка](/ru/why/natural-language-hallucination/).
Перешли на векторы — неоднозначность вернулась.

Изменилась лишь форма.
В естественном языке — неоднозначность слов.
В векторах — неоднозначность координат.

---

## Принцип белого ящика

Здесь обнажается фундаментальная проблема проектирования.

Эмбеддинг-векторы — это чёрный ящик.
Глядя на 768-мерный вектор вещественных чисел,
невозможно понять, какая информация где закодирована.
Сама модель не может это объяснить.

Это не неудобное свойство, а онтологическая характеристика.
Именно поэтому векторы работают.
Поскольку они размещают информацию способами, которые человек не проектировал,
они работают лучше любого человеческого проекта.
Неинтерпретируемость — не баг, а фича.

Однако знания, используемые как контекст ИИ, предъявляют противоположные требования.

Нужно знать источник.
Нужно знать момент времени.
Нужно знать степень уверенности.
Нужно знать, о чём утверждение.
Нужно знать, относятся ли два утверждения к одной сущности.

Каждое требование — «нужно знать». Каждое требование предполагает интерпретируемость.

Удовлетворить требования белого ящика вектором чёрного ящика —
это противоречие.

---

## Логика перехода

Переход от AILEV к GEUL не был отступлением.
Это было переосмысление задачи.

**Исходная задача:** LLM — чёрный ящик. Сделаем внутренности прозрачными.
→ Сделаем эмбеддинг-векторы интерпретируемыми, выровняв их.
→ При изменении векторов модель ломается.
→ Чтобы не ломалась — нужно пересоздать модель.
→ Тупик.

**Переосмысленная задача:** Не нужно делать внутренности чёрного ящика прозрачными. Создадим прозрачный слой снаружи.
→ Внутренности LLM не трогаем.
→ Вне LLM создаём интерпретируемую систему представления.
→ LLM может читать и писать эту систему. Потому что это токены.
→ Искусственный язык.

Не векторы, а язык.
Не непрерывный, а дискретный.
Не неинтерпретируемый, а с интерпретацией как единственной целью.
Не внутри модели, а вне модели.

Из AILEV убрали «Embedding Vector»,
и появился GEUL — что означает «письмо». Вот почему.

---

## Векторы для вычислений, язык для представления

Это не отрицание эмбеддинг-векторов.

Векторы оптимизированы для вычислений.
Поиск по сходству, кластеризация, классификация, извлечение.
Язык не может заменить то, что делают векторы.

Язык оптимизирован для представления.
Идентичность сущностей, описание отношений, встроенные метаданные, интерпретируемость.
Векторы не могут заменить то, что делает язык.

Это инструменты разных уровней.

Внутри LLM работают векторы. Чёрный ящик. Так и должно быть.
Вне LLM работает язык. Белый ящик. Так и должно быть.

Проблема возникла из-за смешения этих двух уровней.
Мы пытались заставить векторы выполнять работу языка.
Мы пытались возложить на чёрный ящик роль белого ящика.

У каждого своё место.

---

## Итоги

Эмбеддинг-векторы — основа LLM и замечательная технология.
Однако как средство представления знаний они имеют фундаментальные ограничения.

GEUL начинался как AILEV (AI Language Embedding Vector).
Цель была — напрямую выровнять векторы и сделать их интерпретируемыми.
Не получилось. По двум причинам.

Произвольное выравнивание векторов разрушает связи, усвоенные моделью.
Выравнивание без разрушения означает пересоздание модели с нуля. Усилия слишком велики.

И даже если бы получилось — векторы не поддаются интерпретации.
В непрерывном пространстве границы дискретных значений размыты.
Нельзя возложить на чёрный ящик роль белого.

Логика перехода:
Пытались сделать внутренности чёрного ящика прозрачными.
При попытке вскрыть — ломается.
Вместо этого — оставить внутренности и построить прозрачный слой снаружи.
Не векторы, а язык. Не внутри модели, а вне модели.

Векторы для вычислений, язык для представления.
У каждого своё место.
