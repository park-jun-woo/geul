---
title: "Почему 16 бит?"
weight: 16
date: 2026-02-26T12:00:04+09:00
lastmod: 2026-02-26T12:00:04+09:00
tags: ["16-bit", "двоичный формат", "поток"]
summary: "Одно слово пронизывает три мира"
author: "Junwoo Park"
authorLink: "https://parkjunwoo.com/1/about"
image: "/images/og-default.webp"
---

## Одно слово пронизывает три мира

---

## Три мира

В информатике существуют три мира.

**Мир сетей.**
Данные текут как потоки байтов.
Байты поступают через TCP-сокеты и байты уходят обратно.
Словарь сетевого инженера -- пакеты, заголовки и полезные нагрузки.

**Мир хранения.**
Данные сохраняются в файловых форматах.
Записываются на диск, считываются с диска.
Словарь инженера хранения -- блоки, смещения и выравнивание.

**Мир ИИ.**
Данные обрабатываются как последовательности токенов.
LLM принимают токены на входе и выдают токены на выходе.
Словарь инженера ИИ -- эмбеддинги, внимание и контекст.

Эти три мира говорят на разных языках.
И между ними всегда требуется перевод.

---

## Цена перевода

Проследим путь данных через современную систему ИИ.

Знание хранится в файле. В формате JSON или обычного текста.

Чтобы передать это ИИ:

1. Открыть файл и прочитать текст.
2. Разобрать текст. Если это JSON, интерпретировать структуру и извлечь поля.
3. Подать извлечённый текст в токенизатор.
4. Токенизатор преобразует текст в последовательность идентификаторов токенов.
5. Последовательность токенов подаётся в LLM.

Когда ИИ генерирует ответ:

6. LLM выдаёт последовательность токенов.
7. Декодировать токены обратно в текст.
8. Сериализовать текст в структурированный формат.
9. Записать сериализованные данные в файл.

Простая операция "прочитать и записать" требует девяти шагов.

Каждый шаг стоит времени.
Каждый шаг стоит памяти.
На каждом шаге возможна потеря информации.

Шаги 3 и 4 -- процесс токенизации -- печально известны своей проблематичностью.
Поскольку границы слов в естественном языке не совпадают с границами токенов токенизатора,
имя собственное вроде "Ли Сунсин" может быть разбито на произвольные фрагменты,
или одна семантическая единица оказывается рассеянной по нескольким токенам.

Такова цена того, что три мира говорят на разных языках.

---

## Что, если бы единый элемент пронизывал все три мира?

В этом языке одно слово -- 16 бит (2 байта).

Одно 16-битное слово одновременно является тремя вещами.

**Единица потока байтов.**
16-битные слова поступают непрерывным потоком по сети.
Big Endian. Выравнивание по 2-байтным границам. Никакого дополнительного разбора не нужно.
Просто читайте их в порядке поступления.

**Единица файлового формата.**
Запишите поток прямо на диск -- и это ваш файл.
Прочтите байты прямо с диска и отправьте по сети -- и это ваш поток.
Без сериализации. Без десериализации.

**Единица токена LLM.**
16 бит = 65 536 различных символов.
Размер словаря современных LLM обычно составляет от 50 000 до 100 000.
Модели семейства GPT используют примерно 50 000; специализированные корейские модели -- около 100 000.
65 536 точно посередине этого диапазона.
Одно 16-битное слово становится одним токеном LLM.

Три мира разделяют одну и ту же единицу.
Перевод исчезает.

---

## Ноль конвертации, ноль потерь, ноль накладных расходов

Посмотрим, что это конкретно означает.

**Традиционный подход: 9 шагов**

```
[Файл] -> Чтение -> Разбор -> Извлечение текста -> Токенизация -> [LLM]
[LLM] -> Декодирование -> Сериализация -> Запись -> [Файл]
```

**Подход бинарного потока: 1 шаг**

```
[Файл/Поток] -> [LLM]
[LLM] -> [Файл/Поток]
```

Прочтите файл -- это уже последовательность токенов.
Запишите последовательность токенов, которую выдаёт LLM -- это уже файл.
Возьмите поток из сети и подайте его прямо в LLM.

Ноль конвертации. Ноль разбора. Ноль токенизации.
Ноль потерь. Ноль накладных расходов.

---

## Почему не 8 бит?

8 бит дают 256 различных символов.

256 символов -- слишком мало для представления мира.
Присвойте алфавит, цифры и основную пунктуацию -- и половина пространства уже занята.

Если использовать 8 бит как фундаментальную единицу,
большинство значимых токенов потребуют 2 или более байтов.
Это вынуждает использовать кодирование переменной длины,
а переменная длина усложняет разбор.

Достаточно как единица потока байтов,
но недостаточно как единица токена.

---

## Почему не 32 бита?

32 бита дают примерно 4,3 миллиарда различных символов.

Выразительная мощность более чем достаточна -- значительно больше, чем необходимо.
Но проблема -- в эффективности.

Самый часто встречающийся пакет в этом формате -- Tiny Verb Edge, размером 2 слова.
При 16 битах на слово это 4 байта. При 32 битах на слово -- 8 байт.
Самый частый пакет удваивается в размере.

С точки зрения LLM тоже есть проблема.
Если один токен -- 32 бита, в одно и то же контекстное окно поместится вдвое меньше токенов.
Учитывая, что длина контекста LLM сегодня -- дефицитный ресурс,
пространство, занимаемое токеном, становится неэффективным относительно информации, которую он несёт.

32-битное слово -- излишество как токен для этого языка.

---

## Почему не переменная длина?

UTF-8 -- кодирование переменной длины.
Длина символа варьируется от 1 до 4 байт в зависимости от символа.

Это даёт преимущества в эффективности хранения,
но вносит фатальную слабость в эффективность обработки.

Чтобы найти n-й символ, нужно считать от начала.
Произвольный доступ невозможен.
SIMD-параллельная обработка становится затруднительной.

Этот язык использует слова фиксированной ширины в 16 бит как фундаментальную единицу.
Позиция n-го слова всегда равна n * 2 байта.
Произвольный доступ -- O(1).
SIMD может сравнить несколько слов одной инструкцией.
GPU могут сканировать миллиарды слов параллельно.

Однако на уровне пакетов переменная длина по-прежнему допускается.
Tiny Verb Edge -- 2 слова; Event6 Edge может быть до 8 слов.
Единица слова фиксирована, но единица пакета гибкая.

Эффективность обработки фиксированной ширины в сочетании с выразительностью переменной длины.
16-битное слово достигает обоих одновременно.

---

## Путь, доказанный Unicode

Unicode -- самый успешный стандарт кодирования, когда-либо созданный человечеством.

Базовая единица UTF-16 -- 16 бит (2 байта).
Она представляет 65 536 символов базовой многоязычной плоскости (BMP) в одном слове
и расширяется для символов за её пределами с помощью суррогатных пар (2 слова = 4 байта).

Мы просто следуем этой проверенной структуре.

Представить 65 536 базовых семантических примитивов в одном слове
и расширять составные пакеты на несколько слов.

Так же, как Unicode выражает каждый символ в мире
на основе базовой единицы "один символ = 2 байта",
этот язык выражает каждый элемент рассуждений ИИ
на основе базовой единицы "одно слово = 2 байта".

---

## Обратная совместимость и расширение вверх

Ещё одна сильная сторона 16 бит -- выравнивание.

16 -- кратное 8, делитель 32, делитель 64 и делитель 128.

Это означает, что выравнивание никогда не нарушается, в каком бы направлении вы ни расширялись.

Что, если архитектура трансформера изменится в будущем
и токены станут 32-битными?
Два 16-битных слова составляют один токен. Никаких проблем с выравниванием.

А если 64 бита?
Четыре 16-битных слова составляют один токен. По-прежнему никаких проблем с выравниванием.

И наоборот, что если 8-битная встраиваемая система обрабатывает этот формат?
Просто читайте каждое 16-битное слово как старший байт и младший байт.

Обратная совместимость должна поддерживаться абсолютно.
16-битное слово гарантирует это на физическом уровне.

Мы не можем предсказать размер слова будущих интеллектов,
но кратное выравнивание 16 бит гарантирует совместимость с любым размером.

---

## Тройная структура

Подведём итог.

Одно 16-битное слово одновременно является тремя вещами.

| Мир | Роль одного слова |
|-------|---------------------|
| Сеть | Единица потока байтов |
| Хранение | Единица файлового формата |
| ИИ | Единица токена LLM |

Одна единица пронизывает все три мира.

Сохраните поток как есть -- это файл.
Прочтите файл как есть -- это токены.
Отправьте токены как есть -- это поток.

Без конвертации.
Без перевода.
Без потерь.

Вот почему 16 бит.
Не 8 бит, не 32 бита, не переменная длина.
Число, которое находится точно на пересечении трёх миров.

16.
