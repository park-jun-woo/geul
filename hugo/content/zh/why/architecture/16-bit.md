---
title: "为什么是16位?"
weight: 16
date: 2026-02-26T12:00:04+09:00
lastmod: 2026-02-26T12:00:04+09:00
tags: ["16位", "二进制", "流"]
summary: "一个字贯穿三个世界"
author: "박준우"
authorLink: "https://parkjunwoo.com/1/about"
image: "/images/og-default.webp"
---

## 一个字贯穿三个世界

---

## 三个世界

计算机科学中存在三个世界。

**网络的世界。**
数据以字节流的形式流动。
字节从TCP套接字中进入，字节从中流出。
网络工程师的词汇是数据包、头部和载荷。

**存储的世界。**
数据以文件格式持久化。
写入磁盘，从磁盘读取。
存储工程师的词汇是块、偏移量和对齐。

**AI的世界。**
数据以token序列的形式处理。
LLM接收token并产出token。
AI工程师的词汇是嵌入、注意力和上下文。

这三个世界说着不同的语言。
它们之间始终需要翻译。

---

## 翻译的代价

让我们追溯数据在现代AI系统中经过的路径。

知识存储在文件中。以JSON或纯文本的形式。

要将其传递给AI：

1. 打开文件并读取文本。
2. 解析文本。如果是JSON，解释结构并提取字段。
3. 将提取的文本输入分词器。
4. 分词器将文本转换为token ID序列。
5. token序列被送入LLM。

当AI生成回复时：

6. LLM输出token序列。
7. 将token解码回文本。
8. 将文本序列化为结构化格式。
9. 将序列化数据写入文件。

一个简单的"读写"操作需要九个步骤。

每个步骤消耗时间。
每个步骤消耗内存。
每个步骤都有信息丢失的风险。

步骤3和4——分词过程——尤为棘手。
由于自然语言的词边界与分词器的token边界不对齐，
像"李舜臣"这样的专有名词可能被拆分成任意片段，
或者单个语义单元被分散到多个token中。

这就是三个世界说不同语言所付出的代价。

---

## 如果一个单位能贯穿所有三个世界呢?

在这种语言中，一个字是16位（2字节）。

一个16位的字同时是三样东西。

**字节流的单位。**
16位字以连续流的形式通过网络到达。
大端序。在2字节边界上对齐。无需额外解析。
只需按到达顺序读取即可。

**文件格式的单位。**
将流直接写入磁盘，就是文件。
从磁盘直接读取字节并通过网络发送，就是流。
无需序列化。无需反序列化。

**LLM token的单位。**
16位 = 65,536个不同符号。
现代LLM的词汇表大小一般在50,000到100,000之间。
GPT系列模型大约使用50,000个；韩语专用模型约100,000个。
65,536恰好处于该范围的中心。
一个16位字就是一个LLM token。

三个世界共享同一个单位。
翻译消失了。

---

## 零转换、零损失、零开销

让我们看看这具体意味着什么。

**传统方式：9个步骤**

```
[文件] -> 读取 -> 解析 -> 提取文本 -> 分词 -> [LLM]
[LLM] -> 解码 -> 序列化 -> 写入 -> [文件]
```

**二进制流方式：1个步骤**

```
[文件/流] -> [LLM]
[LLM] -> [文件/流]
```

读取文件，它已经是token序列。
写出LLM产生的token序列，它已经是文件。
从网络获取流并直接送入LLM。

零转换。零解析。零分词。
零损失。零开销。

---

## 为什么不是8位?

8位给你256个不同符号。

256个符号远不足以表示世界。
分配完字母表、数字和基本标点符号后，一半空间已经用完。

如果用8位作为基本单位，
大多数有意义的token最终需要2个或更多字节。
这迫使使用变长编码，
而变长使解析变得复杂。

作为字节流单位足够，
但作为token单位不够。

---

## 为什么不是32位?

32位给你大约43亿个不同符号。

表达能力绰绰有余——远超所需。
但问题是效率。

这种格式中出现频率最高的数据包是Tiny Verb Edge，为2个字。
以16位每字计算是4字节。以32位每字计算则变成8字节。
最常见的数据包体积翻倍。

从LLM的角度来看，也存在问题。
如果单个token是32位，相同上下文窗口中能容纳的token数量减半。
鉴于LLM上下文长度在今天是稀缺资源，
token占用的空间相对于其携带的信息变得低效。

32位字对于这种语言而言作为token过于冗余。

---

## 为什么不用变长?

UTF-8是变长编码。
字符长度根据字符不同从1字节到4字节不等。

这在存储效率上有优势，
但在处理效率上引入了致命弱点。

要找到第n个字符，必须从头开始计数。
随机访问不可能。
SIMD并行处理变得困难。

这种语言使用固定宽度的16位字作为基本单位。
第n个字的位置始终是 n * 2 字节。
随机访问是O(1)。
SIMD可以在单条指令中比较多个字。
GPU可以并行扫描数十亿个字。

但在数据包层面，仍然允许变长。
Tiny Verb Edge是2个字；Event6 Edge最多可达8个字。
字单位是固定的，但数据包单位是灵活的。

固定宽度的处理效率与变长的表达能力兼而有之。
16位字同时实现了两者。

---

## Unicode证明的道路

Unicode是人类创造的最成功的编码标准。

UTF-16的基本单位是16位（2字节）。
它用单个字表示基本多文种平面（BMP）的65,536个字符，
并使用代理对（2个字 = 4字节）扩展到超出范围的字符。

我们只是沿用这个经过验证的结构。

用单个字表示65,536个基本语义原语，
并将复合数据包扩展到多个字。

正如Unicode在"一个字符 = 2字节"的基本单位上
表达世界上的每一个字符，
这种语言在"一个字 = 2字节"的基本单位上
表达AI推理的每一个要素。

---

## 向后兼容与向上扩展

16位的另一个优势是对齐。

16是8的倍数，是32的约数，是64的约数，是128的约数。

这意味着无论向哪个方向扩展，对齐永远不会被打破。

如果未来transformer架构改变，
token变成32位呢?
两个16位字组成一个token。没有对齐问题。

64位呢?
四个16位字组成一个token。仍然没有对齐问题。

反过来，如果8位嵌入式系统处理这种格式呢?
只需将每个16位字读为高字节和低字节即可。

必须绝对维持向后兼容性。
16位字在物理层面保证了这一点。

我们无法预测未来智能体的字大小，
但16位的倍数对齐保证了与任何大小的兼容性。

---

## 三重结构

让我们总结一下。

一个16位字同时是三样东西。

| 世界 | 一个字的角色 |
|------|-------------|
| 网络 | 字节流的单位 |
| 存储 | 文件格式的单位 |
| AI | LLM token的单位 |

一个单位贯穿所有三个世界。

将流直接存储，就是文件。
将文件直接读取，就是token。
将token直接发送，就是流。

无需转换。
无需翻译。
无损失。

这就是为什么是16位。
不是8位，不是32位，不是变长。
恰好位于三个世界交汇处的数字。

16。
