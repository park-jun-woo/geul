---
title: "왜 기계적 검증이 필요한가"
weight: 4
date: 2026-02-26T12:00:10+09:00
lastmod: 2026-02-26T12:00:10+09:00
tags: ["검증", "규격", "컴파일러"]
summary: "자연어에는 유효하지 않은 문장이라는 개념이 없다"
author: "박준우"
authorLink: "https://parkjunwoo.com/1/about"
image: "/images/og-default.webp"
---

## 자연어에는 "유효하지 않은 문장"이라는 개념이 없다.

---

## 컨텍스트에 들어가는 것을 아무도 검사하지 않는다

현재 LLM 파이프라인에서 정보가 컨텍스트에 들어가는 과정을 보자.

RAG가 청크를 반환한다.
에이전트가 API 응답을 받는다.
이전 대화가 히스토리에 쌓인다.
사용자가 문서를 업로드한다.

이것들이 컨텍스트 윈도우에 들어간다.
검사 없이.

왜 검사가 없는가.
자연어에는 "유효하지 않다"는 개념이 없기 때문이다.

---

## 자연어는 모든 문자열을 받아들인다

프로그래밍에는 구문 오류(syntax error)라는 것이 있다.

```python
def calculate(x, y
    return x + y
```

괄호가 닫히지 않았다. 실행 전에 거부된다.
코드는 실행해보기 전에, 읽어보기도 전에, "이것은 유효한 코드가 아니다"라고 확정할 수 있다.

자연어에는 이것이 없다.

"그는 은행에 갔다."
문법적으로 완벽하다.
누가 어느 은행에 왜 갔는지 알 수 없지만,
자연어의 문법 규칙에 위배되는 것은 없다.

"2024년 13월 45일 매출 보고서."
13월은 없고 45일도 없다.
그러나 자연어의 문법 규칙에 위배되는 것은 없다.
문법적으로 유효한 문장이다.

"출처: 미상. 확신도: 불명. 시점: 불명. 삼성전자의 시가총액은 1200조원이다."
출처도 모르고 확신도도 모르고 언제 기준인지도 모른다.
그러나 자연어의 문법 규칙에 위배되는 것은 없다.

자연어는 모든 것을 받아들인다.
유효하지 않은 자연어 문장은 구조적으로 존재하지 않는다.
따라서 자연어로 된 정보를 "거부"할 기계적 기준이 없다.

---

## 기계적 검증이 가능하려면

Go 컴파일러를 보자.

Go는 사용하지 않는 import가 있으면 컴파일을 거부한다.
코드가 완벽하게 작동하더라도.
로직에 아무 문제가 없더라도.
import 한 줄이 사용되지 않았다는 이유만으로 거부한다.

이것이 기계적 검증이다.

기계적 검증의 특징은 세 가지다.

**확정적이다.** 결과가 예 아니오다. 확률이 아니다. "아마 괜찮을 것이다"가 없다. 유효하거나 유효하지 않다.

**싸다.** LLM 호출이 필요 없다. 문자열 비교, 필드 존재 여부 확인, 값 범위 검사. CPU 나노초 단위의 연산이다.

**의미를 읽지 않는다.** 내용이 맞는지 틀린지 판단하지 않는다. 형식이 규격에 맞는지만 본다. "삼성전자의 시가총액이 1200조원이다"가 사실인지는 모른다. 그러나 출처 필드가 비어 있다는 것은 안다.

이 세 가지가 가능하려면 전제가 하나 있다.
정보가 규격을 가져야 한다.

규격이 있으면 위반이 정의된다.
위반이 정의되면 거부가 가능하다.
거부가 가능하면 검증이 존재한다.

자연어에는 규격이 없으므로 위반이 없고,
위반이 없으므로 거부가 없고,
거부가 없으므로 검증이 없다.

---

## 컨텍스트 진입 전 검증이 필요한 이유

컨텍스트 윈도우는 유한하다.

128K 토큰이든 1M 토큰이든, 유한하다.
유한한 공간에 들어가는 정보의 품질이 출력의 품질을 결정한다.

그런데 현재 파이프라인에서는
정보가 컨텍스트에 들어간 뒤에야 품질 판단이 이루어진다.
LLM이 읽고, 판단하고, "이 정보는 신뢰하기 어렵다"고 스스로 결론 내리기를 기대한다.

이것은 세 가지 점에서 잘못되어 있다.

**비싸다.** LLM 추론 비용으로 형식 검사를 하는 것이다. 출처가 없는 청크를 걸러내기 위해 수십억 파라미터의 모델을 돌린다. 필드 하나 확인하면 될 일을 확률적 추론으로 한다.

**불확실하다.** LLM이 출처 없는 정보를 항상 무시한다는 보장이 없다. 오히려 컨텍스트에 들어온 이상 LLM은 그것을 사용할 가능성이 높다. 컨텍스트에 넣은 것을 무시하라고 기대하는 것은 모순이다.

**늦다.** 이미 윈도우를 차지한 뒤다. 출처 없는 청크 5개가 각각 200토큰이면 1,000토큰이 낭비된다. 걸러내더라도 그 공간은 이미 소진되었다.

기계적 검증은 이 모든 것의 앞에 온다.
컨텍스트에 들어가기 전에.
LLM이 읽기 전에.
윈도우를 차지하기 전에.

---

## 무엇을 검증하는가

기계적 검증이 확인하는 것은 내용의 진위가 아니다.
형식의 규격 준수다.

구체적으로 다음과 같은 것들이다.

**구조 완전성.** 필수 필드가 존재하는가. 엣지에 주어와 목적어가 있는가. 빠진 것이 없는가.

**식별자 유효성.** 참조하는 노드가 존재하는가. "삼성전자"라고 쓴 것이 실제로 정의된 엔티티를 가리키는가. 허공의 참조가 아닌가.

**타입 적합성.** 날짜 필드에 날짜가 있는가. 숫자 필드에 숫자가 있는가. "2024년 13월 45일"은 여기서 걸린다.

**메타데이터 존재.** 출처 필드가 있는가. 시점 필드가 있는가. 확신도가 명시되어 있는가. 없으면 거부하거나, 없음을 표시하거나, 기본값을 부여한다.

**참조 무결성.** 엣지가 가리키는 노드가 실제로 존재하는가. 삭제된 노드를 참조하고 있지는 않은가.

이 검사들의 공통점은 하나다.
전부 내용을 읽지 않고 수행할 수 있다.
"삼성전자의 시가총액이 1200조원이다"가 맞는지 모른다.
그러나 이 서술의 출처가 명시되어 있는지는 안다.
이 서술의 시점이 기록되어 있는지는 안다.
이 서술의 형식이 규격에 맞는지는 안다.

---

## 싼 것이 먼저 온다

컨텍스트 엔지니어링 파이프라인에서 검사에는 순서가 있다.

**기계적 검증**: 규격 준수 여부. 비용 거의 0. 확정적.
**의미적 필터링**: 관련성, 신뢰도, 유용성 판단. 비용 높음. 확률적.
**정합성 검사**: 선택된 정보들 사이의 모순 여부. 비용 더 높음. 추론 필요.

비용이 싼 순서로 배치하면,
비싼 검사가 처리해야 할 양이 줄어든다.

기계적 검증에서 출처 없는 서술 30%를 걸러내면,
의미적 필터링은 70%만 처리하면 된다.
의미적 필터링에서 관련 없는 것을 걸러내면,
정합성 검사는 더 적은 양을 처리한다.

이것은 데이터베이스 쿼리 최적화와 같은 원리다.
WHERE 절에서 인덱스로 걸러낼 수 있는 조건을 먼저 적용한다.
풀 스캔이 필요한 조건은 후순위다.
싼 것이 먼저 오면 비싼 것의 부담이 줄어든다.

반대로,
비싼 검사를 먼저 하고 싼 검사를 나중에 하면
이미 비용을 쓴 뒤에 형식 오류를 발견하게 된다.
존재하지 않는 노드를 참조하는 서술의 의미를 분석한 뒤에야
참조가 무효임을 발견하는 것이다.

---

## 자연어 파이프라인에서는 이 순서가 불가능하다

자연어에는 규격이 없으므로 기계적 검증이 불가능하다.
기계적 검증이 불가능하므로 가장 싼 검사가 존재하지 않는다.

결과적으로 모든 검사가 의미적 검사다.
모든 검사에 LLM이 필요하다.
모든 검사가 비싸다.

"이 청크에 출처가 있는가?" — LLM이 읽어야 한다.
"이 청크의 시점이 적절한가?" — LLM이 읽어야 한다.
"이 청크의 형식이 올바른가?" — 자연어에는 형식이 없으므로 질문 자체가 성립하지 않는다.

이것이 현재 컨텍스트 엔지니어링의 현실이다.
가장 단순한 검사조차 가장 비싼 도구로 수행한다.
문자열 비교로 끝날 일을 추론 엔진으로 처리한다.

---

## 검증의 전제 조건

기계적 검증이 존재하려면 세 가지가 필요하다.

**규격.** 정보가 따라야 할 형식이 정의되어 있어야 한다. 어떤 필드가 필수이고, 어떤 값이 허용되고, 어떤 참조가 유효한지. 규격이 없으면 위반이 정의되지 않는다.

**형식화.** 정보가 그 규격에 맞는 형식으로 표현되어 있어야 한다. 자연어 문장이 아니라, 규격이 요구하는 구조로 인코딩되어 있어야 한다. 형식화되지 않은 정보는 검사할 수 없다.

**거부 권한.** 규격에 맞지 않는 정보를 실제로 거부할 수 있어야 한다. 검사만 하고 통과시키면 검증이 아니다. 유효하지 않은 정보가 컨텍스트에 들어가지 못하게 막아야 한다.

이 세 가지는 프로그래밍 언어에서는 당연한 것이다.
문법이라는 규격이 있고, 코드라는 형식이 있고, 컴파일러라는 거부 권한이 있다.

자연어에서는 세 가지 모두 없다.
문법은 형식 규격이 아니라 관습이고,
문장은 구조화된 형식이 아니라 자유 텍스트이고,
"유효하지 않은 자연어"라는 개념 자체가 없으므로 거부할 것이 없다.

컨텍스트 엔지니어링에 기계적 검증을 도입하려면
정보 표현 자체가 바뀌어야 한다.

---

## 요약

현재 컨텍스트 파이프라인에서는 정보가 검사 없이 컨텍스트에 들어간다.
자연어에 "유효하지 않은 문장"이라는 개념이 없기 때문이다.

기계적 검증은 내용의 진위가 아니라 형식의 규격 준수를 확인한다.
구조 완전성, 식별자 유효성, 타입 적합성, 메타데이터 존재, 참조 무결성.
확정적이고, 싸고, 의미를 읽지 않는다.

파이프라인에서 싼 검사가 먼저 와야 한다.
기계적 검증이 형식 오류를 걸러내면,
비싼 의미적 판단이 처리할 양이 줄어든다.

자연어에는 규격이 없으므로 이 검사가 불가능하다.
모든 검사가 의미적 검사가 되고, 모든 검사가 비싸다.

기계적 검증이 가능하려면
규격이 있고, 형식화되어 있고, 거부가 가능해야 한다.
정보 표현 자체가 바뀌어야 한다.
