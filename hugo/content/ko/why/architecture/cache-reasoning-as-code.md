---
title: "왜 추론을 코드로 캐시하는가"
weight: 18
date: 2026-02-26T12:00:02+09:00
lastmod: 2026-02-26T12:00:02+09:00
tags: ["캐시", "추론", "코드"]
summary: "한 번의 추론을 영구적 절차로 전환한다"
author: "박준우"
authorLink: "https://parkjunwoo.com/1/about"
image: "/images/og-default.webp"
---

# Why Cache Reasoning as Code?

## 추론을 코드로 캐시하는 이유

---

## 매번 처음부터 생각하는 AI

당신이 후배에게 엑셀에서 피벗 테이블 만드는 법을 알려준다고 하자.

첫째 날, 후배가 묻는다. 당신은 30분에 걸쳐 설명한다.
둘째 날, 같은 후배가 같은 질문을 한다. 당신은 다시 30분을 쓴다.
셋째 날에도, 넷째 날에도.

현재의 LLM이 정확히 이렇게 작동한다.

GPT에게 "파이썬으로 CSV 파싱해줘"라고 요청하면, 모델은 수십억 개의 파라미터를 동원해서 처음부터 추론한다. 내일 똑같은 질문을 해도, 모레 해도, 매번 같은 비용을 치른다. 어제의 추론은 증발한다. 기록되지 않고, 재사용되지 않고, 축적되지 않는다.

이것은 캐시 없이 작동하는 웹 서버와 같다.
메모 없이 같은 시험 문제를 반복해서 푸는 학생과 같다.
그리고 경험이 축적되지 않는 지능은 결코 성장하지 않는다.

---

## LLM은 컴파일러다. 런타임 엔진이 아니다.

SEGLAM은 이 문제에 대해 근본적으로 다른 답을 제시한다.

**LLM은 매 요청을 실행하는 런타임 엔진이 아니라,
추론을 코드로 결정화(crystallize)하는 컴파일러다.**

작동 방식은 이렇다:

1. 요청이 들어오면, 먼저 추론 캐시를 확인한다.
2. **캐시 히트(Cache Hit):** 이전에 동일하거나 유사한 추론이 이미 코드로 결정화되어 있다. LLM을 호출하지 않는다. 해당 코드를 즉시 실행한다. 빠르고, 저렴하고, 결정적(deterministic)이다.
3. **캐시 미스(Cache Miss):** 처음 만나는 유형의 추론이다. 이때 LLM이 호출된다. 그러나 LLM은 "답변"을 생성하는 것이 아니라 **"그 답변을 생성하는 코드"**를 생성한다. 이 코드가 캐시에 추가된다.

다음에 유사한 요청이 오면? 캐시 히트다. LLM은 잠자고 있어도 된다.

---

## JIT 컴파일러와의 유비

이 구조는 컴퓨터 과학에서 이미 검증된 패턴의 재발견이다.

JIT(Just-In-Time) 컴파일러를 생각해보자. Java나 JavaScript 엔진은 처음에는 코드를 인터프리터로 한 줄씩 실행한다. 느리지만 작동은 한다. 그러다 같은 코드 경로가 반복 실행되면 -- "이건 자주 쓰이는 경로구나" -- 엔진이 해당 경로를 네이티브 머신 코드로 컴파일한다. 이후부터는 인터프리터를 거치지 않고 직접 실행된다.

SEGLAM에서:

- **인터프리터 = LLM.** 느리고, 비싸고, 확률적이지만, 어떤 요청이든 처리할 수 있다.
- **네이티브 코드 = 캐시된 추론 코드.** 빠르고, 저렴하고, 결정적이다.
- **JIT 컴파일 = 캐시 미스 시 LLM이 코드를 생성하는 과정.** 비용이 들지만, 한 번이면 된다.

JIT 컴파일러가 "자주 쓰이는 경로(hot path)"를 최적화하듯,
SEGLAM은 "자주 쓰이는 추론(hot reasoning)"을 코드로 결정화한다.

---

## 왜 "답변"이 아니라 "코드"를 캐시하는가?

이것이 핵심이다. 단순한 응답 캐시와 SEGLAM의 추론 캐시는 근본적으로 다르다.

**응답 캐시**는 "Q: 한국의 수도는? -> A: 서울"을 저장한다. 질문이 정확히 일치해야만 히트한다. "대한민국의 수도는?"이라고 물으면 미스다. 이것은 사전이지 지능이 아니다.

**SEGLAM의 추론 캐시**는 "이런 유형의 질문에 이런 절차로 답변을 구성하라"는 코드를 저장한다. 구체적인 값이 아니라 추론의 경로 자체를 결정화하는 것이다. 따라서 입력이 달라져도, 같은 유형이면 히트한다. 이것은 이해이며 성장이다.

비유하자면: 응답 캐시는 곱셈표를 외우는 것이고, 추론 캐시는 곱셈하는 법을 배우는 것이다.

---

## 시간이 흐르면 무슨 일이 일어나는가

이 설계의 가장 강력한 특성은 **시간의 편**이라는 것이다.

- **Day 1:** 캐시가 비어 있다. 거의 모든 요청이 캐시 미스다. LLM이 열심히 일한다. 느리고 비싸다.
- **Day 30:** 일상적인 추론 패턴의 상당수가 캐시되어 있다. LLM 호출이 줄어든다.
- **Day 365:** 대부분의 요청이 캐시 히트다. LLM은 진정으로 새로운 유형의 문제에만 호출된다. 시스템은 빠르고, 저렴하고, 예측 가능해진다.
- **그 이후:** 캐시 자체가 해당 도메인의 "결정화된 지능"이 된다. 이식 가능하고, 검증 가능하고, 축적 가능한 지적 자산이다.

LLM에 대한 의존은 시간이 갈수록 감소한다.
시스템의 효율은 시간이 갈수록 증가한다.
이 곡선은 결코 뒤집히지 않는다.

---

## 추론 기록의 원칙

이 접근의 가장 근본적인 원칙은 이것이다:

> "AI의 추론 과정은 버려지지 않고 기록되어야 한다."

추론 캐시는 이 철학의 가장 직접적인 구현이다.

LLM이 한 번 수행한 추론은 구조화된 표현으로 결정화되어 저장된다. 버려지지 않는다. 재사용된다. 검증된다. 개선된다. 축적된다.

그리고 이 캐시된 코드는 명확한 구조화된 언어로 기술되어 있기 때문에:

- 왜 그런 절차가 만들어졌는지 **추적할 수 있고,**
- 절차가 잘못되었을 때 **수정할 수 있고,**
- 더 나은 절차가 발견되었을 때 **교체할 수 있다.**

블랙박스 안에서 매번 증발하는 추론이 아니라,
화이트박스 위에 축적되는 지능. 그것이 추구해야 할 AI의 모습이다.

---

## 요약

| 기존 LLM | SEGLAM |
|-----------|--------|
| 매 요청마다 처음부터 추론 | 캐시 히트 시 코드 즉시 실행 |
| 추론 결과 증발 | 추론이 코드로 결정화되어 축적 |
| 비용이 사용량에 비례 | 비용이 시간이 갈수록 감소 |
| LLM = 런타임 엔진 | LLM = 컴파일러 |
| 블랙박스 추론 | 검증·수정·교체 가능한 코드 |

LLM을 매번 불러 세우는 것은 비행기를 타고 옆집에 가는 것과 같다.
한 번 길을 내면, 그 다음부터는 걸어가면 된다.

SEGLAM은 길을 내는 시스템이다.
