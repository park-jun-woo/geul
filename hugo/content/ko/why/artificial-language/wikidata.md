---
title: "왜 위키데이터인가"
weight: 13
date: 2026-02-26T12:00:17+09:00
lastmod: 2026-02-26T12:00:17+09:00
tags: ["위키데이터", "온톨로지", "SIDX"]
summary: "GEUL은 위키데이터를 부정하지 않는다. 1억 개 엔티티의 분류 체계와 빈도 통계를 SIDX 코드북으로 변환한다. 사전 위에 문법을 얹는다."
author: "박준우"
authorLink: "https://parkjunwoo.com/1/about"
image: "/images/og-default.webp"
---

## GEUL은 위키데이터를 부정하지 않는다. 위키데이터 위에 선다.

---

## 사전 없이 언어를 만들 수 없다

언어에는 단어장이 필요하다.

한글에는 한국어 사전이 있다.
영어에는 영어 사전이 있다.
프로그래밍 언어에는 표준 라이브러리가 있다.

인공언어도 마찬가지다.
엔티티의 목록, 관계의 목록, 속성의 목록.
"삼성전자"가 이 언어에서 어떤 코드인지,
"수도(capital)"라는 관계가 어떤 코드인지,
단어장이 있어야 문장을 쓸 수 있다.

이 단어장을 어떻게 만드는가.
두 가지 방법이 있다.

처음부터 만든다.
또는 이미 있는 것을 가져다 쓴다.

---

## 처음부터 만든다: CYC의 교훈

CYC 프로젝트는 1984년에 시작했다.

범용 상식 지식을 형식화하여 저장하겠다는 목표.
온톨로지를 처음부터 설계했다.
개념을 정의하고, 관계를 정의하고, 규칙을 정의했다.
전문가들이 수작업으로 입력했다.

30년이 지났다.
수백만 개의 규칙이 입력되었다.

그러나 세계의 지식을 커버하기에는 턱없이 부족했다.
도메인마다 온톨로지를 따로 설계해야 했다.
도메인 간 일관성을 유지하기 어려웠다.
새로운 개념이 등장할 때마다 온톨로지를 수정해야 했다.
수정이 기존 규칙과 충돌하는 경우가 빈번했다.

CYC가 증명한 것은 가능성이 아니라 한계였다.
소수의 전문가가 세계의 온톨로지를 설계하는 것은
규모가 커지면 유지 불가능하다.

---

## 이미 있는 것: 위키데이터

위키데이터(Wikidata)는 2012년에 시작했다.

위키미디어 재단이 운영하는 구조화된 지식 베이스.
누구나 편집할 수 있다.
2024년 기준, 1억 개 이상의 엔티티.
1만 개 이상의 속성.
수십억 개의 서술.
300개 이상의 언어로 레이블.

CYC가 30년간 전문가 팀으로 못 이룬 규모를
위키데이터는 10년간 커뮤니티로 이뤘다.

위키데이터가 가진 것을 보자.

**엔티티 식별자.** Q-ID. 삼성전자는 Q20718. 서울은 Q8684. 이순신은 Q217300. 전 세계에서 유일한 식별자. 언어에 무관하다.

**속성 식별자.** P-ID. "본사 소재지"는 P159. "설립일"은 P571. "인구"는 P1082. 관계와 속성이 고유하게 식별된다.

**계층 구조.** P31(instance of)과 P279(subclass of)로 타입 계층이 형성된다. "서울 → 도시 → 인간 거주지 → 지리적 개체." 세계의 분류 체계가 이 두 속성으로 표현된다.

**다국어 레이블.** Q20718의 한국어 레이블은 "삼성전자", 영어 레이블은 "Samsung Electronics", 일본어 레이블은 "サムスン電子". 식별자는 하나, 이름은 언어마다 다르다.

**커뮤니티 검증.** 수백만 편집자. 반달리즘 감지. 출처 요구. 완벽하지 않지만, 소수의 전문가보다 확장 가능하다.

이것을 처음부터 만들 이유가 없다.

---

## GEUL의 단어장은 위키데이터에서 온다

GEUL의 SIDX(Semantic-aligned Index)는 64비트 의미정렬 식별자다.
비트 자체에 의미 정보가 담겨 있다.
상위 비트만 봐도 "이것이 사람인지, 장소인지, 조직인지" 알 수 있다.

이 SIDX의 코드북 — 어떤 비트 패턴이 어떤 의미를 갖는지 — 은
위키데이터에서 추출된다.

과정은 이렇다.

**1단계: 타입 추출.**
위키데이터에서 P31(instance of)의 목적어로 사용된 모든 Q-ID를 추출한다.
이것이 "타입"의 목록이다.
"인간(Q5)", "도시(Q515)", "국가(Q6256)", "기업(Q4830453)"...
각 타입이 몇 번 사용되었는지 — 인스턴스 수 — 를 집계한다.

**2단계: 계층 구축.**
타입 간의 P279(subclass of) 관계를 추출한다.
"도시 → 인간 거주지 → 지리적 개체 → 개체."
이것이 타입의 트리 구조를 형성한다.
루트 노드, 리프 노드, 중간 노드를 식별한다.
다중 상속 — 하나의 타입이 여러 상위 타입에 속하는 경우 — 을 검출하고 처리한다.

**3단계: 비트 할당.**
트리의 구조가 비트 패턴의 접두사 관계를 결정한다.
같은 상위 타입에 속하는 하위 타입들은 같은 접두사를 공유한다.
"도시"와 "마을"은 "인간 거주지"의 접두사를 공유한다.

인스턴스 수가 비트 길이에 영향을 준다.
자주 쓰이는 타입은 더 효율적인 코드를 받는다.
허프만 코딩과 같은 원리다. 빈도가 높은 것에 짧은 코드를.

---

## 위키데이터가 제공하는 것

이 과정에서 위키데이터가 제공하는 것은 세 가지다.

**분류 체계.**
"세계에 어떤 종류의 것들이 있는가"에 대한 답.
CYC는 이것을 전문가 팀이 설계했다.
GEUL은 위키데이터에서 추출한다.
수백만 편집자가 10년간 합의한 분류 체계를
비트 트리로 변환하는 것이다.

**빈도 통계.**
"어떤 종류의 것이 세계에 얼마나 있는가"에 대한 답.
인간 엔티티가 900만 개이고 소행성이 100만 개라면,
"인간"이라는 타입이 "소행성"보다 더 효율적인 코드를 받아야 한다.
실제 사용 빈도가 코드 설계를 결정한다.

**식별자 매핑.**
위키데이터의 Q-ID와 GEUL의 SIDX 간의 매핑.
Q20718(삼성전자)이 SIDX에서 어떤 비트 패턴에 해당하는지.
이 매핑이 있으면 위키데이터의 지식을 GEUL로 변환할 수 있고,
GEUL의 서술을 위키데이터로 역변환할 수 있다.

---

## 위키데이터가 제공하지 않는 것

위키데이터는 사전이다. 사전이 언어는 아니다.

사전은 단어의 목록을 제공한다.
언어는 단어로 문장을 만드는 문법을 제공한다.

위키데이터가 제공하지 않는 것은 GEUL이 추가하는 부분이다.

**Fact에서 Claim으로.**
위키데이터의 기본 단위는 사실(Fact)이다.
"서울의 인구는 974만이다."
참이거나 거짓이다.

GEUL의 기본 단위는 주장(Claim)이다.
"A에 따르면, 서울의 인구는 약 974만이다. (확신도 0.9, 시점 2023)"
누가, 얼마나 확실하게, 언제 기준으로 주장하는지가 서술에 포함된다.
이 차이는 [왜 사실이 아니라 주장인가](/ko/why/claims-not-facts/)에서 상세히 다룬다.

**동사 한정사.**
위키데이터에는 동사의 미묘함을 표현할 자리가 없다.
"이순신은 명량해전에서 승리했다"에서
시제, 상, 증거성, 서법, 확신도가 어디에 있는가.
위키데이터에서 이것은 퀄리파이어로 부분적으로 표현되지만,
체계적인 동사 한정 체계는 없다.

GEUL은 28비트의 동사 한정자 시스템을 가진다.
13가지 차원 — 시제, 상, 극성, 증거성, 서법, 의도성, 확신성 등 — 이
모든 서술에 구조적으로 내장된다.

**16비트 압축.**
위키데이터의 표현은 컨텍스트 윈도우를 위해 설계되지 않았다.
JSON-LD, RDF, SPARQL.
기계가 읽을 수 있지만 토큰 효율적이지 않다.

GEUL은 16비트 워드 단위로 설계되었다.
LLM의 토큰과 1:1 매핑.
컨텍스트 윈도우의 유한함을 전제로 한 표현 체계다.
이것은 [왜 MD/JSON/XML로는 안 되는가](/ko/why/not-md-json-xml/)에서 이미 다뤘다.

**컨텍스트 파이프라인.**
위키데이터는 저장소다. GEUL은 파이프라인의 일부다.
명료화, 검증, 필터링, 정합성 검사, 탐색 — 이 시리즈에서 논의한 모든 것이
GEUL의 구조화된 표현 위에서 작동한다.
위키데이터에는 이 파이프라인이 없다.
있을 필요도 없다. 위키데이터의 목적은 다르니까.

---

## 사전과 언어의 관계

정리하면 이렇다.

위키데이터는 세계의 단어장이다.
어떤 엔티티가 존재하는지,
어떤 관계가 존재하는지,
어떤 타입이 있고 그것들이 어떻게 분류되는지.
이것을 10년간 수백만 명이 쌓았다.

GEUL은 이 단어장 위에 문법을 얹는다.
단어장의 분류 체계 → SIDX의 비트 트리.
단어장의 빈도 통계 → 비트 할당의 우선순위.
단어장의 식별자 → SIDX와의 매핑.

그리고 단어장에 없는 것을 추가한다.
주장의 구조. 동사의 한정. 토큰 수준의 압축. 컨텍스트 파이프라인.

위키데이터 없이 GEUL을 만들 수 있는가.
만들 수 있다. CYC처럼 처음부터 온톨로지를 설계하면 된다.
그러나 그것은 30년 전에 시도되었고, 결과가 나와 있다.

위키데이터가 있으므로 GEUL은 온톨로지를 설계하지 않는다.
이미 존재하는 합의를 변환한다.

---

## 요약

인공언어에는 단어장이 필요하다.
단어장을 처음부터 만드는 것은 CYC가 시도했고, 30년이 한계를 증명했다.

위키데이터는 1억 개 이상의 엔티티, 1만 개 이상의 속성, 수십억 개의 서술을 가진 세계의 단어장이다.
수백만 편집자가 10년간 쌓은 것이다.

GEUL의 SIDX 코드북은 위키데이터에서 추출된다.
P31의 인스턴스 빈도가 비트 할당을 결정하고,
P279의 계층 구조가 비트 트리의 뼈대를 형성한다.

위키데이터는 사전이고 GEUL은 언어다.
사전은 단어를 제공하고, 언어는 문법을 제공한다.
GEUL은 위키데이터의 단어장 위에 주장의 구조, 동사 한정, 16비트 압축, 컨텍스트 파이프라인을 얹는다.

GEUL은 위키데이터를 부정하지 않는다.
위키데이터 위에 선다.
