---
title: "למה MD/JSON/XML לא יעבדו"
weight: 9
date: 2026-02-26T12:00:15+09:00
lastmod: 2026-02-26T12:00:15+09:00
tags: ["פורמט", "JSON", "XML"]
summary: "פורמטים קיימים אינם מסוגלים לשאת משמעות"
author: "박준우"
authorLink: "https://parkjunwoo.com/1/about"
image: "/images/og-default.webp"
---

## פורמטים מובנים כבר קיימים. אז למה צריך שפה חדשה?

---

## ההתנגדות הנפוצה ביותר

כשמישהו נתקל לראשונה ברעיון של שפת הסקה ל-AI, הדבר הראשון שהוא אומר הוא:

"פורמטים מובנים כבר קיימים, לא?"

הם צודקים. הם קיימים. רבים מהם.

יש Markdown.
יש JSON.
יש XML.
YAML, TOML, Protocol Buffers, MessagePack, CSV...

העולם מוצף בפורמטי נתונים.
אז למה AI עדיין חושב בשפה טבעית?

כדי לענות על השאלה הזו, חייבים לזהות בדיוק מה כל פורמט עושה טוב
ומה הוא לא מסוגל לעשות.

---

## Markdown: הזיכרון הנוכחי של סוכני AI

נכון ל-2026, הפורמט הנפוץ ביותר בשימוש סוכני AI הוא Markdown.

Claude Code זוכר בקבצי `.md`.
סוכנים מבוססי GPT גם משאירים הערות ב-Markdown.
CLAUDE.md, memory.md, notes.md.
הזיכרון ארוך-הטווח של AI עומד על Markdown ברגע זה ממש.

למה Markdown? הסיבה פשוטה.
LLM-ים קוראים וכותבים Markdown היטב.
Markdown מרובה בנתוני אימון,
והמבנה שלו פשוט מספיק ליצירה וניתוח קלים.

אבל Markdown הוא **פורמט מסמכים שנועד לבני אדם לקרוא.**

```markdown
# Project Status
## Cache Strategy
- SIMD bitmask adopted (decided 1/28)
- GPU acceleration under review
## Unresolved
- Query generation method TBD
```

איך מכונה מפרשת את זה?

יש כותרת סעיף שנקראת "Cache Strategy."
מתחתיה, יש פריט "SIMD bitmask adopted."
יש תאריך "(1/28)" בסוגריים.

מכונה לא יכולה להבין את זה מבנית.
היא יכולה לדעת מ-`##` ש-"Cache Strategy" היא כותרת סעיף,
אבל הקשר הסמנטי שהוא "תת-נושא של ארכיטקטורה" לא קיים ב-Markdown.
אדם יודע ש-"1/28" הוא תאריך, אבל מכונה צריכה לנחש.
28 בינואר, או אחד חלקי עשרים ושמונה?

בסופו של דבר, כדי "להבין" Markdown, LLM חייב לבצע פרשנות שפה טבעית.
Markdown הוא שפה טבעית עם הזחה על גביה ---
הוא לא נתונים מובנים.

---

## JSON: מבנה ללא משמעות

JSON הולך צעד אחד מעבר ל-Markdown.

```json
{
  "entity": "Yi Sun-sin",
  "birth": "1545",
  "death": "1598",
  "occupation": "naval_commander"
}
```

יש מבנה. זוגות מפתח-ערך מפורשים.
מכונה יכולה לנתח את זה. שדות נגישים.

אבל יש בעיה.

**JSON לא יודע מה המפתח "entity" אומר.**

האדם שיצר את ה-JSON הזה יודע ש-"entity" פירושו "אובייקט."
ב-JSON של אדם אחר, אותו מושג יכול להיות "name," "subject" או "item."

```json
{"name": "Yi Sun-sin"}
{"subject": "Yi Sun-sin"}
{"item": "Yi Sun-sin"}
{"entity": "Yi Sun-sin"}
```

ארבעה JSON-ים מבטאים את אותו הדבר,
אבל מכונה לא יכולה לדעת שהם זהים.

ל-JSON חסרה **סמנטיקה משותפת.**
יש מבנה, אבל אין הסכמה על מה שהמבנה הזה אומר.

כל פרויקט יוצר סכמה משלו.
כל API משתמש בשמות שדות משלו.
חיבור סכמה A לסכמה B דורש עוד שכבת המרה.

זה מגדל בבל.
מבנה קיים, אבל אף אחד לא מבין את המבנה של האחר.

---

## XML: מס המילוליות

XML ניסה לפתור את בעיית JSON.

מרחבי שמות, הגדרות סכמה (XSD), הגדרות סוג מסמך (DTD).
הוא מספק מטא-מבנים שמגדירים את משמעות המבנים.

```xml
<entity xmlns="http://example.org/schema">
  <name>Yi Sun-sin</name>
  <birth>
    <year>1545</year>
    <calendar>lunar</calendar>
  </birth>
  <death>
    <year>1598</year>
    <cause>killed_in_action</cause>
  </death>
</entity>
```

ניתן להגדיר משמעות. ניתן לאכוף מבנה עם סכמות.
זה יותר קפדני מ-JSON.

אבל ל-XML יש בעיה קטלנית.

**הוא מילולי.**

ב-XML למעלה, המידע בפועל הוא "Yi Sun-sin, 1545, 1598, killed_in_action."
כל השאר הם תגיות. תגיות פתיחה וסגירה עולות על המידע.

למה זו בעיה ל-AI?

חלון ההקשר של LLM הוא סופי.
אם העברת אותו מידע דורשת פי 3 טוקנים,
כמות המידע שנכנסת להקשר מצטמצמת לשליש.

XML מילולי כדי שבני אדם יקראו אותו בקלות.
שפת הסקה ל-AI לא צריכה את הבזבוז הזה.
ל-LLM, תגית `<name>` היא בזבוז.

ו-XML הוא עיצוב מתחילת שנות ה-2000.
הוא נוצר בעידן שבו LLM-ים לא היו קיימים, עבור בני אדם ותוכנה מסורתית.
הוא מעולם לא תוכנן כשפת הסקה ל-AI.

---

## המגבלה המשותפת

Markdown, JSON, XML.
לכל אחד מארבעת הפורמטים יש חוזקות, אבל הם חולקים מגבלות משותפות.

**הם מבוססי טקסט.**
כולם עוברים סריאליזציה למחרוזות.
מכונה חייבת לנתח אותם כדי לעבד אותם.
ניתוח הוא עלות.

שפת הסקה אידיאלית היא זרם בינארי.
רצף מילים בנות 16 ביט. אין צורך בניתוח.
ניתנת לפרשנות ברגע שנקראת.

**הם תוכננו לפני עידן ה-LLM.**
Markdown הוא מ-2004. JSON הוא מ-2001. XML הוא מ-1998.
הם תוכננו בעידן שבו מושג ה-LLM לא היה קיים,
עבור בני אדם או תוכנה מסורתית.

שפת הסקה ל-AI חייבת להיות מתוכננת בעידן ה-LLM, עבור LLM-ים.
עקרון העיצוב "מילה אחת = טוקן אחד"
מניח מראש את קיומם של LLM-ים.

**מערכת סמנטית מאוחדת שלהם נעדרת או חלקית.**
ל-Markdown אין מערכת סמנטית כלל.
ל-JSON יש מבנה אבל אין משמעות.
XML יכול להגדיר סכמות אבל הן לא מאוחדות.

אינדקס מיושר-סמנטית הוא מזהה משמעות מאוחד גלובלית.
בכל מקום שהוא משמש, אותו SIDX אומר את אותו הדבר.
אין צורך בהמרה. הסכמה מובנית.

---

## סיכום

| פורמט | מבנה | משמעות | ידידותי ל-LLM | בינארי | תמיכה בטענות | משני פועל |
|--------|-----------|---------|---------------|--------|---------------|----------------|
| Markdown | חלש | אין | גבוה | לא | אין | אין |
| JSON | כן | אין | בינוני | לא | אין | אין |
| XML | כן | חלקי | נמוך | לא | אין | אין |
| **שפת הסקה אידיאלית** | **כן** | **כן** | **גבוה** | **כן** | **כן** | **כן** |

פורמט חדש נדרש לא כי פורמטים קיימים גרועים.
אלא כי פורמטים קיימים נוצרו בעידן אחר, למטרה אחרת.

Markdown נוצר למסמכים שבני אדם קוראים.
JSON נוצר להחלפת נתונים ב-API-ים של אינטרנט.
XML נוצר לסריאליזציה כללית של מסמכים ונתונים.

פורמט לרישום ולצבירה של הסקת AI. זה עדיין לא קיים.

כשהמטרה שונה, הכלי חייב להיות שונה.
