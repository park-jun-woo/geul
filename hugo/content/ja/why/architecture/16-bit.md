---
title: "なぜ16ビットなのか?"
weight: 16
date: 2026-02-26T12:00:04+09:00
lastmod: 2026-02-26T12:00:04+09:00
tags: ["16ビット", "バイナリ", "ストリーム"]
summary: "一つのワードが三つの世界を貫く"
author: "박준우"
authorLink: "https://parkjunwoo.com/1/about"
image: "/images/og-default.webp"
---

## 一つのワードが三つの世界を貫く

---

## 三つの世界

コンピュータサイエンスには三つの世界がある。

**ネットワークの世界。**
データはバイトストリームとして流れる。
TCPソケットからバイトが入り、バイトが出ていく。
ネットワークエンジニアの語彙は、パケット、ヘッダ、ペイロード。

**ストレージの世界。**
データはファイルフォーマットとして永続化される。
ディスクに書き込み、ディスクから読み出す。
ストレージエンジニアの語彙は、ブロック、オフセット、アライメント。

**AIの世界。**
データはトークン列として処理される。
LLMはトークンを受け取り、トークンを出力する。
AIエンジニアの語彙は、エンベディング、アテンション、コンテキスト。

この三つの世界は異なる言語を話している。
そしてその間には、常に翻訳が必要とされる。

---

## 翻訳のコスト

現代のAIシステムをデータが通過する経路を追ってみよう。

知識はファイルに格納されている。JSONやプレーンテキストとして。

これをAIに届けるには：

1. ファイルを開いてテキストを読む。
2. テキストをパースする。JSONであれば構造を解釈しフィールドを抽出する。
3. 抽出したテキストをトークナイザに入力する。
4. トークナイザがテキストをトークンIDの列に変換する。
5. トークン列がLLMに入力される。

AIが応答を生成するとき：

6. LLMがトークン列を出力する。
7. トークンをテキストにデコードする。
8. テキストを構造化フォーマットにシリアライズする。
9. シリアライズされたデータをファイルに書き込む。

単純な「読み書き」操作に9つのステップが必要。

各ステップが時間を消費する。
各ステップがメモリを消費する。
各ステップが情報損失のリスクを伴う。

ステップ3と4——トークナイゼーション過程——は特に厄介だ。
自然言語の語境界がトークナイザのトークン境界と一致しないため、
「李舜臣」のような固有名詞が任意の断片に分割されたり、
一つの意味単位が複数のトークンに散らばったりする。

これが、三つの世界が異なる言語を話すことの代償である。

---

## もし一つの単位が三つの世界すべてを貫いたら?

この言語では、一つのワードは16ビット（2バイト）である。

一つの16ビットワードは同時に三つのものである。

**バイトストリームの単位。**
16ビットワードがネットワークを通じて連続的に到着する。
ビッグエンディアン。2バイト境界でアライメント。追加のパースは不要。
到着順に読み取るだけでよい。

**ファイルフォーマットの単位。**
ストリームをそのままディスクに書き込めば、それがファイルになる。
ディスクからバイトをそのまま読み出してネットワークに送れば、それがストリームになる。
シリアライズ不要。デシリアライズ不要。

**LLMトークンの単位。**
16ビット = 65,536種の異なるシンボル。
現代のLLM語彙サイズは一般に50,000から100,000の範囲。
GPT系モデルは約50,000を使用し、韓国語特化モデルは約100,000。
65,536はその範囲のちょうど中央に位置する。
一つの16ビットワードが一つのLLMトークンになる。

三つの世界が同じ単位を共有する。
翻訳が消える。

---

## ゼロ変換、ゼロ損失、ゼロオーバーヘッド

これが具体的に何を意味するか見てみよう。

**従来のアプローチ：9ステップ**

```
[ファイル] -> 読取 -> パース -> テキスト抽出 -> トークナイズ -> [LLM]
[LLM] -> デコード -> シリアライズ -> 書込 -> [ファイル]
```

**バイナリストリームアプローチ：1ステップ**

```
[ファイル/ストリーム] -> [LLM]
[LLM] -> [ファイル/ストリーム]
```

ファイルを読めば、それはすでにトークン列である。
LLMが生成するトークン列を書き出せば、それはすでにファイルである。
ネットワークからストリームを取得し、直接LLMに入力する。

ゼロ変換。ゼロパース。ゼロトークナイゼーション。
ゼロ損失。ゼロオーバーヘッド。

---

## なぜ8ビットではないのか?

8ビットで256種の異なるシンボルが得られる。

256シンボルでは世界を表すには少なすぎる。
アルファベット、数字、基本句読点を割り当てれば、半分のスペースは使い切ってしまう。

8ビットを基本単位にすると、
ほとんどの意味あるトークンは2バイト以上を必要とする。
これは可変長エンコーディングを強制し、
可変長はパースを複雑にする。

バイトストリームの単位としては適切だが、
トークンの単位としては不十分である。

---

## なぜ32ビットではないのか?

32ビットで約43億種の異なるシンボルが得られる。

表現力は十分すぎる——必要をはるかに超えている。
しかし問題は効率である。

このフォーマットで最も頻出するパケットはTiny Verb Edgeで2ワード。
16ビット/ワードなら4バイト。32ビット/ワードなら8バイトになる。
最も一般的なパケットのサイズが倍増する。

LLMの観点からも問題がある。
一つのトークンが32ビットなら、同じコンテキストウィンドウに入るトークン数は半減する。
LLMのコンテキスト長が今日の希少なリソースであることを考えると、
トークンが占めるスペースは、それが運ぶ情報に対して非効率になる。

32ビットワードはこの言語のトークンとしてはオーバーキルである。

---

## なぜ可変長ではないのか?

UTF-8は可変長エンコーディングである。
文字によって1バイトから4バイトまで変わる。

これは記憶効率に利点があるが、
処理効率に致命的な弱点をもたらす。

n番目の文字を見つけるには、先頭から数えなければならない。
ランダムアクセスは不可能。
SIMD並列処理が困難になる。

この言語は固定幅16ビットワードを基本単位とする。
n番目のワードの位置は常に n * 2 バイト。
ランダムアクセスはO(1)。
SIMDは一命令で複数のワードを比較できる。
GPUは数十億のワードを並列スキャンできる。

ただしパケットレベルでは可変長が許容される。
Tiny Verb Edgeは2ワード、Event6 Edgeは最大8ワード。
ワード単位は固定だが、パケット単位は柔軟。

固定幅の処理効率と可変長の表現力を兼ね備える。
16ビットワードは両方を同時に実現する。

---

## Unicodeが証明した道

Unicodeは人類が創造した最も成功したエンコーディング標準である。

UTF-16の基本単位は16ビット（2バイト）。
基本多言語面（BMP）の65,536文字を一つのワードで表現し、
サロゲートペア（2ワード = 4バイト）でそれを超える文字に拡張する。

私たちはこの実証済みの構造に従うだけである。

65,536の基本意味プリミティブを一つのワードで表現し、
複合パケットを複数のワードにまたがって拡張する。

Unicodeが「一文字 = 2バイト」の基本単位の上に
世界のあらゆる文字を表現するように、
この言語は「一ワード = 2バイト」の基本単位の上に
AI推論のあらゆる要素を表現する。

---

## 後方互換性と上方拡張

16ビットのもう一つの強みはアライメントである。

16は8の倍数であり、32の約数であり、64の約数であり、128の約数である。

これは、どの方向に拡張してもアライメントが崩れないことを意味する。

将来トランスフォーマーアーキテクチャが変わり、
トークンが32ビットになったら？
二つの16ビットワードが一つのトークンになる。アライメントの問題はない。

64ビットなら？
四つの16ビットワードが一つのトークンになる。やはりアライメントの問題はない。

逆に、8ビットの組み込みシステムがこのフォーマットを処理する場合は？
各16ビットワードを上位バイトと下位バイトに分けて読むだけでよい。

後方互換性は絶対に維持されなければならない。
16ビットワードはこれを物理レベルで保証する。

将来の知性体のワードサイズを予測することはできないが、
16ビットの倍数アライメントがあらゆるサイズとの互換性を保証する。

---

## 三重構造

まとめよう。

一つの16ビットワードは同時に三つのものである。

| 世界 | 一ワードの役割 |
|------|--------------|
| ネットワーク | バイトストリームの単位 |
| ストレージ | ファイルフォーマットの単位 |
| AI | LLMトークンの単位 |

一つの単位が三つの世界すべてを貫く。

ストリームをそのまま保存すれば、それがファイルになる。
ファイルをそのまま読めば、それがトークンになる。
トークンをそのまま送れば、それがストリームになる。

変換不要。
翻訳不要。
損失なし。

これが、なぜ16ビットなのかという答えである。
8ビットでもなく、32ビットでもなく、可変長でもない。
三つの世界の交差点に正確に位置する数。

16。
