# WMS (GEUL World Management System) 알고리즘 상세 사양서 (v1.0)

**문서 번호:** WMS-ALG-001
**작성일:** 202X.XX.XX
**대상 시스템:** GEUL World Engine Core (Go/Assembly/CUDA)

-----

## 1\. ID 체계 및 주소 매핑 알고리즘 (Addressing)

### 1.1 Semantic ID 구조 (64-bit)

모든 노드와 엣지는 아래 64비트 정수 하나로 물리적 주소가 결정된다.

```text
MSB [ Flag(1) | Category(4) | Tier(3) | Index(56) ] LSB
```

  * `Flag`: 0=Static(Disk/mmap), 1=Dynamic(Mem)
  * `Category`: 저장소 파티션 결정 (Person, Weapon, Event...)
  * `Tier`: 중요도 등급 (SIMD 필터링 가속용)
  * `Index`: 해당 배열 내의 오프셋

### 1.2 $O(1)$ Direct Address Calculation

별도의 B-Tree나 Hash Lookup 없이 ID만으로 메모리 포인터를 계산한다.

**Algorithm: `GetNodeAddress(ID)`**

```go
Input: ID (uint64)
Output: *Node (Memory Pointer)

1. Region = (ID >> 63) & 0x1
2. Category = (ID >> 59) & 0x0F
3. Index = ID & 0x00FFFFFFFFFFFFFF

4. IF Region == 0 (Static):
     BasePtr = MmapBasePtrs[Category] // 미리 로드된 mmap 시작 주소
     Offset = Index * sizeof(Node)    // Node 크기는 64byte 고정
     Return (BasePtr + Offset)

5. ELSE (Dynamic):
     // 동적 배열은 리사이징 가능하므로 Slice Header 참조
     Return &DynamicArrays[Category][Index]
```

  * **Time Complexity:** $O(1)$ - 산술 연산 3회, 메모리 접근 1회.

-----

## 2\. SIMD 비트마스크 필터링 (Hard Filtering)

### 2.1 개요

1억 개의 ID 배열에서 특정 조건(카테고리, 티어)을 만족하는 ID만 0.01초 내에 추출한다. AVX2 (256-bit) 또는 AVX-512 명령어를 사용한다.

**Algorithm: `SIMD_Filter(IDs[], Mask, Pattern)`**

```go
Input: 
  IDs[]: []uint64 (1억 개)
  Mask:  uint64 (예: 0xF800000000000000 - 상위 5비트 검사)
  Pattern: uint64 (예: 0x1000000000000000 - Category 2번만)

Output: 
  Candidates[]: []uint64 (조건 만족 ID 리스트)

Process (Pseudo-Assembly):
1. Loop i from 0 to N step 4 (AVX2 기준, 64bit * 4 = 256bit):
     // 1. 데이터 로드
     YMM0 = Load_256bit(&IDs[i])
     
     // 2. 마스킹 (AND 연산)
     // Mask 값을 가진 YMM1 레지스터와 AND
     YMM2 = VPAND(YMM0, YMM1) 
     
     // 3. 비교 (Compare Equality)
     // Pattern 값을 가진 YMM3 레지스터와 비교
     // 일치하면 0xFFFFFFFFFFFFFFFF, 아니면 0x00...
     YMM4 = VPCMPEQQ(YMM2, YMM3)
     
     // 4. 비트마스크 추출 (Move Mask)
     // 각 64비트 요소의 MSB를 모아 4비트 정수로 변환
     ResMask = VMOVMSKPD(YMM4)
     
     // 5. 결과 저장 (Compress Store / Permute)
     IF ResMask != 0:
         // ResMask에 해당하는 인덱스만 Candidates에 추가
         // (이 부분은 분기 예측 실패 비용 방지를 위해 Branchless로 구현)
         Append_Matching_IDs(Candidates, YMM0, ResMask)
```

  * **Time Complexity:** $O(N/K)$ (K=SIMD Lane Width). 실제 체감 속도는 메모리 대역폭(Bandwidth) 한계에 수렴.

-----

## 3\. 엣지 저장 및 탐색 (Graph Traversal)

### 3.1 분리 저장소 (Segregated Storage) 접근

가변 길이 엣지를 고정 길이 슬랩(Slab)으로 관리하여 단편화를 제거한다.

**Algorithm: `GetEdgePayload(EdgeID)`**

```go
Input: EdgeID (uint32)
Output: []uint32 (Payload Indices)

1. LenClass = (EdgeID >> 30) & 0x03 // 상위 2비트
2. Index = EdgeID & 0x3FFFFFFF

3. Switch LenClass:
     Case 0 (3-Term):
         Stride = 4 (Header + 3)
         TargetArray = Zone0_Array
     Case 1 (4-Term):
         Stride = 5 (Header + 4)
         TargetArray = Zone1_Array
     Case 2 (5-Term):
         Stride = 6 (Header + 5)
         TargetArray = Zone2_Array

4. Offset = Index * Stride
5. Return TargetArray[Offset : Offset + Stride] // Slice 반환 (Copy 없음)
```

### 3.2 CSR (Compressed Sparse Row) 기반 N-hop 탐색

소스 노드 ID를 알 때, 연결된 모든 엣지를 루프 없이 즉시 가져온다.

**Data Structure:**

  * `EdgeData[]`: 소스 ID 순서로 정렬된 엣지 데이터 (Zone별 분리)
  * `OffsetTable[]`: `OffsetTable[SourceID]` = 해당 소스의 엣지 시작 인덱스

**Algorithm: `GetEdgesBySource(SourceID, Zone)`**

```go
Input: SourceID (uint32), Zone (int)
Output: []Edge (연속된 메모리 블록)

1. StartIdx = OffsetTable[Zone][SourceID]
2. EndIdx   = OffsetTable[Zone][SourceID + 1]

3. IF StartIdx == EndIdx:
     Return Empty // 엣지 없음

// Go의 Slice는 포인터 뷰이므로 복사 비용 0 (Zero-Copy)
4. Return EdgeData[Zone][StartIdx : EndIdx]
```

  * **Time Complexity:** $O(1)$ (배열 인덱싱 2회).

-----

## 4\. 동적 데이터 관리 (LSM-Tree Style)

### 4.1 쓰기 (Write - Append Only)

동적 영역에 엣지를 추가할 때 Lock 경합을 최소화한다.

**Algorithm: `InsertEdge(Edge)`**

```go
1. Acquire WriteLock (짧은 시간)
2. Append Edge to HotBuffer (메모리 배열)
3. Release WriteLock
```

### 4.2 읽기 (Read - Merge)

정적 영역(CSR)과 동적 영역(Buffer)을 합쳐서 읽는다.

**Algorithm: `QueryEdges(SourceID)`**

```go
1. StaticResults = GetEdgesBySource_CSR(SourceID) // Tier 1 (매우 빠름)
2. DynamicResults = Scan(HotBuffer, SourceID)     // Tier 2 (작아서 빠름)
3. Return Merge(StaticResults, DynamicResults)
```

### 4.3 압축 및 정렬 (Background Compaction)

유휴 시간에 수행되는 프로세스.

**Algorithm: `Compact()`**

```go
1. IF HotBuffer is Empty: Return
2. Snapshot = Copy(HotBuffer) // ReadLock만 걸고 스냅샷 뜸
3. Sort Snapshot by SourceID (QuickSort)

// Merge Sort 알고리즘 적용
4. NewCSR, NewOffsets = Merge_Sorted_Arrays(OldCSR, Snapshot)

5. Acquire Global WriteLock
6. Replace Pointers:
     OldCSR = NewCSR
     OldOffsets = NewOffsets
     Clear(HotBuffer)
7. Release Global WriteLock
```

-----

## 5\. SLT 추론 파이프라인 (Neuro-Symbolic)

### 5.1 입력 텐서 구성 (Zero-Copy)

Go의 구조체 데이터를 Python/PyTorch용 텐서 포맷으로 변환 없이 매핑한다.

**Algorithm: `PrepareInputTensor(Candidates[])`**

```go
Input: Candidates[] (Node Struct List)
Output: *Tensor (ONNX Input)

1. Allocate Float32 Buffer (Size = N * EmbeddingDim)
2. Parallel Loop i in Candidates:
     // 각 후보의 속성(GEUL Vector)을 Buffer에 채움
     // 의미정렬 ID의 비트 정보를 Vector Feature로 변환 (Embedding Lookup 아님)
     Buffer[i] = DeconstructID_To_Feature(Candidates[i].ID)

3. Return Wrap_As_Tensor(Buffer, Shape=[N, Dim])
```

### 5.2 추론 및 정렬

**Algorithm: `RankBySLT(QueryVec, Candidates)`**

```go
1. InputTensor = PrepareInputTensor(Candidates)
2. QueryTensor = Repeat(QueryVec, len(Candidates))

// ONNX Runtime 호출 (CGO -> CUDA)
3. Scores = SLT_Session.Run([QueryTensor, InputTensor]) 
   // Scores는 [N, 1] Float32 배열

// ArgSort (점수 기반 정렬)
4. SortedIndices = Argsort(Scores, Descending)

5. Return Reorder(Candidates, SortedIndices)
```

-----

## 6\. ETL 파이프라인 (Wikidata Import)

### 6.1 스트림 필터링

거대 JSON 파일을 메모리 폭발 없이 처리.

**Algorithm: `ProcessWikiDump(Stream)`**

```go
1. Reader = Bzip2Reader(Stream)
2. OutputBuffers = Map[Category]Buffer

3. Loop while !EOF:
     Entity = ReadNextJSONEntity(Reader)
     
     // 1차 필터 (P31 Check)
     Category = MapP31ToGEULCategory(Entity.Claims["P31"])
     IF Category == None: Continue
     
     // ID 발급 (Atomic Increment)
     Index = AtomicAdd(GlobalCounters[Category], 1)
     SemID = (Category << 59) | Index
     
     // 데이터 변환
     NodeData = ConvertToGEULNode(Entity, SemID)
     
     // 버퍼 쓰기
     OutputBuffers[Category].Write(NodeData)

4. Flush All Buffers to Disk (.bin files)
```

-----

## 7\. 복잡도 요약 (Performance Summary)

| 연산 (Operation) | 알고리즘 | 시간 복잡도 | 비고 |
| :--- | :--- | :--- | :--- |
| **Node 조회** | Bit-shift Addressing | **$O(1)$** | Memory Access 1회 |
| **Filtering** | SIMD Bitmask | **$O(N/256)$** | 사실상 Memory Bandwidth 속도 |
| **Edge 탐색** | CSR Indexing | **$O(1)$** | Offset 조회 2회 |
| **Edge 로딩** | Segregated Slab | **$O(1)$** | 곱셈 1회 (`Idx * Stride`) |
| **Scoring** | Matrix Multiplication | **$O(N \cdot d^2)$** | GPU 가속 (병렬 처리) |

이 사양서는 WMS의 성능을 보장하는 **수학적/논리적 근거**입니다. 구현 시 이 알고리즘들을 준수하면 목표하신 성능을 달성할 수 있습니다.