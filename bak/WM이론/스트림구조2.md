# ìŠ¤íŠ¸ë¦¼êµ¬ì¡°.md

**GEUL Stream Format Specification v2.0**  
**ì‘ì„±ì¼:** 2024-12-03  
**ëŒ€ìƒ:** WMS-GPT ì¸í„°í˜ì´ìŠ¤ ë ˆì´ì–´

---

## ëª©ì°¨

1. [ê°œìš”](#1-ê°œìš”)
2. [16-bit ì›Œë“œ ê¸°ë°˜ ì² í•™](#2-16-bit-ì›Œë“œ-ê¸°ë°˜-ì² í•™)
3. [ê¸°ë³¸ íƒ€ì… ì‹œìŠ¤í…œ](#3-ê¸°ë³¸-íƒ€ì…-ì‹œìŠ¤í…œ)
4. [ìŠ¤íŠ¸ë¦¼ ì „ì²´ êµ¬ì¡°](#4-ìŠ¤íŠ¸ë¦¼-ì „ì²´-êµ¬ì¡°)
5. [TIDMAP](#5-tidmap)
6. [ë…¸ë“œ íŒ¨í‚·](#6-ë…¸ë“œ-íŒ¨í‚·)
7. [ì—£ì§€ íŒ¨í‚·](#7-ì—£ì§€-íŒ¨í‚·)
8. [ì˜ˆì‹œ ìŠ¤íŠ¸ë¦¼](#8-ì˜ˆì‹œ-ìŠ¤íŠ¸ë¦¼)
9. [GPT í†µí•©](#9-gpt-í†µí•©)

---

## 1. ê°œìš”

### 1.1 GEULì´ë€?

**GEUL (General Embedding Universal Language)** ì€ GPTì™€ WMS ì‚¬ì´ì˜ ì¸í„°í˜ì´ìŠ¤ ì–¸ì–´ì…ë‹ˆë‹¤.

```
ì—­í• :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ìì—°ì–´ ì§ˆì˜  â”‚ (ì‚¬ìš©ì)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GPT         â”‚ ìì—°ì–´ â†’ GEUL ë³€í™˜
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â†“ GEUL Stream (16-bit ì›Œë“œ)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ WMS        â”‚ GEUL â†’ ë‚´ë¶€ ì¿¼ë¦¬ ì‹¤í–‰
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â†“ GEUL Stream (ê²°ê³¼)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GPT         â”‚ GEUL â†’ ìì—°ì–´ ë³€í™˜
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ìì—°ì–´ ì‘ë‹µ  â”‚ (ì‚¬ìš©ì)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ì„¤ê³„ ëª©í‘œ

```
1. GPT í† í°í™” ê°€ëŠ¥
   - ëª¨ë“  ê²ƒì´ 16-bit ì›Œë“œ
   - GPT vocabê³¼ 1:1 ë§¤í•‘ ê°€ëŠ¥
   - ì»¨í…ìŠ¤íŠ¸ ìœˆë„ìš° íš¨ìœ¨ì  ì‚¬ìš©

2. ëª…í™•ì„±
   - íƒ€ì… ëª…ì‹œì 
   - ëª¨í˜¸ì„± ì œê±°
   - ìê¸° ê¸°ìˆ ì  (self-describing)

3. ì»´íŒ©íŠ¸í•¨
   - TID ê°„ì ‘ ì°¸ì¡° (1ì›Œë“œ)
   - SIDX ì§ì ‘ ì°¸ì¡° (4ì›Œë“œ)
   - ì„ íƒì  ì‚¬ìš©

4. í™•ì¥ì„±
   - ë²„ì „ ê´€ë¦¬
   - í•˜ìœ„ í˜¸í™˜
   - íƒ€ì… ì¶”ê°€ ìš©ì´
```

---

## 2. 16-bit ì›Œë“œ ê¸°ë°˜ ì² í•™

### 2.1 ì›Œë“œ = ê¸°ë³¸ ë‹¨ìœ„

```
ëª¨ë“  GEUL ë°ì´í„°ëŠ” 16-bit ì›Œë“œì˜ ë°°ì—´:

1 ì›Œë“œ = 16 bits = 2 bytes

ì˜ˆì‹œ:
[0x0100][0x0004][0x0001][0x0042]
  ì›Œë“œ1   ì›Œë“œ2   ì›Œë“œ3   ì›Œë“œ4

ì´ 4ì›Œë“œ = 8 bytes = 64 bits
```

### 2.2 GPT í† í°ê³¼ì˜ ê´€ê³„

```
GPT Tokenizer:
- BPE vocab: ~100K í† í°
- ê° í† í° = ì •ìˆ˜ ID

GEUL ì›Œë“œ:
- 16-bit ì •ìˆ˜ = 65,536 ê°€ëŠ¥
- GPT vocabì˜ ì¼ë¶€ë¡œ í•™ìŠµ ê°€ëŠ¥

ì˜ˆì‹œ:
GPT: [í† í°1][í† í°2][í† í°3]...
GEUL: [ì›Œë“œ1][ì›Œë“œ2][ì›Œë“œ3]...
â†’ 1:1 ë§¤í•‘ ê°€ëŠ¥
```

### 2.3 ì •ë ¬ ë° íŒ¨ë”©

```
ëª¨ë“  íŒ¨í‚·ì€ ì›Œë“œ ê²½ê³„ ì •ë ¬:
- íŒ¨í‚· í¬ê¸° = N ì›Œë“œ (ì§ìˆ˜ ë°”ì´íŠ¸)
- í•„ìš”ì‹œ íŒ¨ë”© ì›Œë“œ ì¶”ê°€

ì˜ˆ:
3ì›Œë“œ í•„ìš” â†’ 4ì›Œë“œ í• ë‹¹ (1ì›Œë“œ íŒ¨ë”©)
5ì›Œë“œ í•„ìš” â†’ 6ì›Œë“œ í• ë‹¹ (1ì›Œë“œ íŒ¨ë”©)
```

---

## 3. ê¸°ë³¸ íƒ€ì… ì‹œìŠ¤í…œ

### 3.1 TypeId (1ì›Œë“œ)

```
TypeId: 16-bit
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 8 bits â”‚    8 bits      â”‚
â”‚ Class  â”‚   Subtype      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Class (ìƒìœ„ 8ë¹„íŠ¸):
0x00 = META     (Header, TIDMAP)
0x01 = NODE     (Entity, Context, QuantitySpec)
0x02 = EDGE     (Triple, Event6)
0x03 = PRIMITIVE (Integer, Float, String)
0xFF = RESERVED

Subtype (í•˜ìœ„ 8ë¹„íŠ¸):
Node:
  0x0100 = Entity
  0x0101 = Context
  0x0102 = QuantitySpec

Edge:
  0x0200 = Triple
  0x0201 = Event6
  0x0202 = Relation

Meta:
  0x0000 = StreamHeader
  0x0001 = TIDMAP Entry
  0x0002 = Section Marker
```

### 3.2 ê¸°ë³¸ ì°¸ì¡° íƒ€ì…

```
TID (Temporary ID): 1ì›Œë“œ
- 0x0000 = NULL
- 0x0001~0xFFFF = ìœ íš¨ ID (65,535ê°œ)

SIDX (Meaning ID): 4ì›Œë“œ
- 64-bit ì˜ë¯¸ì •ë ¬ ID
- [ì›Œë“œ1][ì›Œë“œ2][ì›Œë“œ3][ì›Œë“œ4]
```

### 3.3 ê¸¸ì´ í‘œí˜„

```
Length: 1ì›Œë“œ
- íŒ¨í‚· ì „ì²´ ê¸¸ì´ (ì›Œë“œ ìˆ˜)
- í—¤ë” í¬í•¨

ì˜ˆ:
Length = 0x0006 â†’ 6ì›Œë“œ = 12 bytes
```

---

## 4. ìŠ¤íŠ¸ë¦¼ ì „ì²´ êµ¬ì¡°

### 4.1 ë ˆì´ì•„ì›ƒ

```
GEUL Stream (ìˆœì„œ ì¤‘ìš”)

[StreamHeader]          (í•„ìˆ˜, ì²« íŒ¨í‚·)
â”œâ”€ Magic: 0x4745554C   ("GEUL")
â”œâ”€ Version: 1ì›Œë“œ
â”œâ”€ Flags: 1ì›Œë“œ
â””â”€ Count: 1ì›Œë“œ        // ì „ì²´ íŒ¨í‚· ìˆ˜

[TIDMAP Section]        (í•„ìˆ˜, TID ì‚¬ìš© ì‹œ)
â”œâ”€ Section Marker
â”œâ”€ TIDMAP Entry 1
â”œâ”€ TIDMAP Entry 2
â””â”€ ...

[Node Packets]          (ì˜µì…˜)
â”œâ”€ Entity 1
â”œâ”€ Context 1
â”œâ”€ QuantitySpec 1
â””â”€ ...

[Edge Packets]          (ì˜µì…˜)
â”œâ”€ Triple 1
â”œâ”€ Triple 2
â”œâ”€ Event6 1
â””â”€ ...

[End Marker]            (ì˜µì…˜)
â””â”€ TypeId: 0xFFFF
```

### 4.2 StreamHeader ìƒì„¸

```
TypeId:   0x0000 (META/StreamHeader)
Length:   0x0008 (8ì›Œë“œ = 16 bytes)

[ì›Œë“œ1] TypeId     = 0x0000
[ì›Œë“œ2] Length     = 0x0008
[ì›Œë“œ3] Magic-Hi   = 0x4745  // "GE"
[ì›Œë“œ4] Magic-Lo   = 0x554C  // "UL"
[ì›Œë“œ5] Version    = 0x0100  // v1.0
[ì›Œë“œ6] Flags      = 0x0000
[ì›Œë“œ7] PacketCount-Hi = 0x0000
[ì›Œë“œ8] PacketCount-Lo = 0x0042  // 66ê°œ íŒ¨í‚·

Flags:
  bit[0]: HAS_TIDMAP (1 = TIDMAP ì¡´ì¬)
  bit[1]: COMPRESSED (1 = ì••ì¶•ë¨)
  bit[2-15]: Reserved
```

---

## 5. TIDMAP

### 5.1 ëª©ì 

```
TID (1ì›Œë“œ) â†” SIDX (4ì›Œë“œ) ë§¤í•‘

ì¥ì :
- 1ì›Œë“œë¡œ ì—”í‹°í‹° ì°¸ì¡° â†’ 4ë°° ì••ì¶•
- 65,535ê°œê¹Œì§€ ì••ì¶• ê°€ëŠ¥
- ìì£¼ ì°¸ì¡°ë˜ëŠ” ì—”í‹°í‹°ë§Œ TIDMAP ë“±ë¡

ë‹¨ì :
- ê°„ì ‘ ì°¸ì¡° ì˜¤ë²„í—¤ë“œ
- TIDMAP íŒŒì‹± í•„ìš”
```

### 5.2 Section Marker

```
TypeId:   0x0002 (META/SectionMarker)
Length:   0x0004 (4ì›Œë“œ)

[ì›Œë“œ1] TypeId     = 0x0002
[ì›Œë“œ2] Length     = 0x0004
[ì›Œë“œ3] Section    = 0x0001  // TIDMAP
[ì›Œë“œ4] EntryCount = 0x0010  // 16ê°œ ì—”íŠ¸ë¦¬
```

### 5.3 TIDMAP Entry

```
TypeId:   0x0001 (META/TIDMAP_Entry)
Length:   0x0006 (6ì›Œë“œ = TID 1ì›Œë“œ + SIDX 4ì›Œë“œ + í—¤ë”)

[ì›Œë“œ1] TypeId  = 0x0001
[ì›Œë“œ2] Length  = 0x0006
[ì›Œë“œ3] TID     = 0x0001
[ì›Œë“œ4] SIDX-1   = 0x0100  // SIDX ìƒìœ„
[ì›Œë“œ5] SIDX-2   = 0x0000
[ì›Œë“œ6] SIDX-3   = 0x0000
[ì›Œë“œ7] SIDX-4   = 0x0042  // SIDX í•˜ìœ„

â†’ TID 0x0001 = SIDX 0x0100000000000042
```

### 5.4 ì˜ˆì‹œ: TIDMAP Section

```
[0x0002][0x0004][0x0001][0x0003]  // Section Marker: TIDMAP, 3ê°œ
[0x0001][0x0006][0x0001][0x0100][0x0000][0x0000][0x0001]  // Alice
[0x0001][0x0006][0x0002][0x0100][0x0000][0x0000][0x0002]  // Bob
[0x0001][0x0006][0x0003][0x0500][0x0000][0x0000][0x0100]  // RealWorld
```

---

## 6. ë…¸ë“œ íŒ¨í‚·

### 6.1 ê³µí†µ êµ¬ì¡°

```
ëª¨ë“  ë…¸ë“œ íŒ¨í‚·: 4ì›Œë“œ ê³ ì •

[ì›Œë“œ1] TypeId
[ì›Œë“œ2] Length = 0x0004
[ì›Œë“œ3] ID (TID ë˜ëŠ” SIDX ì‹œì‘)
[ì›Œë“œ4] Data
```

### 6.2 Entity íŒ¨í‚·

```
TypeId:   0x0100 (NODE/Entity)
Length:   0x0004 (4ì›Œë“œ = 8 bytes)

[ì›Œë“œ1] TypeId  = 0x0100
[ì›Œë“œ2] Length  = 0x0004
[ì›Œë“œ3] TID     = 0x0001  // Entity TID
[ì›Œë“œ4] Flags   = 0x0201  // ìƒíƒœ/ì—­í•  í”Œë˜ê·¸

Flags (16-bit):
  [0-7]:   ìƒíƒœ (ACTIVE, DELETED, ...)
  [8-15]:  ì—­í•  (PRESIDENT, HERO, ...)

ì˜ˆì‹œ:
[0x0100][0x0004][0x0001][0x0201]
  Entity   4ì›Œë“œ   Alice  Flags(í™œì„±,ëŒ€í†µë ¹)
```

### 6.3 Context íŒ¨í‚·

```
TypeId:   0x0101 (NODE/Context)
Length:   0x0004 (4ì›Œë“œ = 8 bytes)

[ì›Œë“œ1] TypeId  = 0x0101
[ì›Œë“œ2] Length  = 0x0004
[ì›Œë“œ3] TID     = 0x0003  // Context TID
[ì›Œë“œ4] Flags   = 0x0100  // Modality ë“±

Flags (16-bit):
  [0-7]:   Modality (REAL, FICTION, MEMORY, ...)
  [8-15]:  Reserved

ì˜ˆì‹œ:
[0x0101][0x0004][0x0003][0x0100]
  Context  4ì›Œë“œ   Ctx#3  REAL

ì£¼ì˜: Contextì˜ ìƒì„¸ ì •ë³´(world, time, pov)ëŠ” ì—£ì§€ë¡œ ì„œìˆ !
```

**Context ìƒì„¸ ì„œìˆ  ì˜ˆì‹œ:**
```
Context ë…¸ë“œ:
[0x0101][0x0004][0x0003][0x0100]  // Context TID=3

Context ì†ì„± ì—£ì§€ë“¤:
[0x0200][0x0008][0x0003][0x0001][0x0003][0x0010][0x0000][0x0000]
  Triple  8ì›Œë“œ   Ctx#3  Prop:World Obj:RealWorld

[0x0200][0x0008][0x0003][0x0002][0x0003][0x0042][0x0000][0x0000]
  Triple  8ì›Œë“œ   Ctx#3  Prop:Time  Obj:2020

[0x0200][0x0008][0x0003][0x0003][0x0003][0x0001][0x0000][0x0000]
  Triple  8ì›Œë“œ   Ctx#3  Prop:POV   Obj:Alice
```

### 6.4 QuantitySpec íŒ¨í‚·

```
TypeId:   0x0102 (NODE/QuantitySpec)
Length:   0x0004 (4ì›Œë“œ)

[ì›Œë“œ1] TypeId  = 0x0102
[ì›Œë“œ2] Length  = 0x0004
[ì›Œë“œ3] TID     = 0x0005  // QuantitySpec TID
[ì›Œë“œ4] Spec    = 0xXXXX  // íƒ€ì…/ë‹¨ìœ„ ì¸ì½”ë”©

Spec (16-bit):
  [0-3]:   ValueType (INT/FLOAT/FIXED)
  [4-7]:   BitWidth (16/32/64)
  [8-15]:  UnitId (meter, second, USD, ...)

ì˜ˆì‹œ:
[0x0102][0x0004][0x0005][0x0141]
  QuantSpec 4ì›Œë“œ  Spec#5  INT32/meter
```

---

## 7. ì—£ì§€ íŒ¨í‚·

### 7.1 Triple íŒ¨í‚·

```
TypeId:   0x0200 (EDGE/Triple)
Length:   0x0008 (8ì›Œë“œ = 16 bytes)

[ì›Œë“œ1] TypeId   = 0x0200
[ì›Œë“œ2] Length   = 0x0008
[ì›Œë“œ3] CtxTID   = 0x0003  // Context
[ì›Œë“œ4] SubjTID  = 0x0001  // Subject
[ì›Œë“œ5] PropId-Hi = 0x0000
[ì›Œë“œ6] PropId-Lo = 0x0042  // Property (32-bit)
[ì›Œë“œ7] ObjTID   = 0x0002  // Object
[ì›Œë“œ8] Reserved = 0x0000

ì˜ˆì‹œ:
[0x0200][0x0008][0x0003][0x0001][0x0000][0x0042][0x0002][0x0000]
  Triple  8ì›Œë“œ   Ctx#3  Alice   Prop:Friend    Bob    Reserved

ì˜ë¯¸: "Context#3ì—ì„œ, AliceëŠ” Bobê³¼ ì¹œêµ¬ë‹¤"
```

### 7.2 Event6 íŒ¨í‚·

```
TypeId:   0x0201 (EDGE/Event6)
Length:   0x0010 (16ì›Œë“œ = 32 bytes)

[ì›Œë“œ1]  TypeId    = 0x0201
[ì›Œë“œ2]  Length    = 0x0010
[ì›Œë“œ3]  CtxTID    = 0x0003  // Context
[ì›Œë“œ4]  Presence  = 0x003F  // 6-bit mask
[ì›Œë“œ5]  WhoTID    = 0x0001  // Who
[ì›Œë“œ6]  WhatTID   = 0x0010  // What
[ì›Œë“œ7]  WhomTID   = 0x0002  // Whom
[ì›Œë“œ8]  WhenTID   = 0x0020  // When
[ì›Œë“œ9]  WhereTID  = 0x0030  // Where
[ì›Œë“œ10] WhyTID    = 0x0040  // Why
[ì›Œë“œ11-16] Reserved

Presence (16-bit):
  bit[0]: Who
  bit[1]: What
  bit[2]: Whom
  bit[3]: When
  bit[4]: Where
  bit[5]: Why
  bit[6-15]: Reserved

ì˜ˆì‹œ:
[0x0201][0x0010][0x0003][0x003F]...
  Event6  16ì›Œë“œ  Ctx#3  ëª¨ë“ í•„ë“œì¡´ì¬
  
[0x0001][0x0010][0x0002][0x0020][0x0030][0x0040]
  Alice  Give   Bob    2020   NYC    Gift
  
[0x0000][0x0000][0x0000][0x0000][0x0000][0x0000]
  (Reserved 6ì›Œë“œ)

ì˜ë¯¸: "2020ë…„ NYCì—ì„œ, Aliceê°€ Bobì—ê²Œ ì„ ë¬¼ì„ ì£¼ì—ˆë‹¤"
```

### 7.3 Property Edge (Context ìƒì„¸ ì„œìˆ ìš©)

```
Context ë…¸ë“œëŠ” 4ì›Œë“œë¡œ ê°„ë‹¨íˆ ì •ì˜:
[0x0101][0x0004][TID][Flags]

ìƒì„¸ ì •ë³´ëŠ” Property Tripleë¡œ ì„œìˆ :

1. World ì†ì„±:
[0x0200][0x0008][CtxTID][SubjTID=CtxTID]
[PropId=WORLD][WorldTID][0x0000][0x0000]

2. Time ì†ì„±:
[0x0200][0x0008][CtxTID][SubjTID=CtxTID]
[PropId=TIME][TimeTID or Value][0x0000][0x0000]

3. POV ì†ì„±:
[0x0200][0x0008][CtxTID][SubjTID=CtxTID]
[PropId=POV][POVTID][0x0000][0x0000]

ì¥ì :
- Context ë…¸ë“œ ìì²´ëŠ” 4ì›Œë“œë¡œ ê²½ëŸ‰
- í•„ìš”í•œ ì†ì„±ë§Œ ì„ íƒì ìœ¼ë¡œ ì¶”ê°€
- í™•ì¥ ìš©ì´ (ìƒˆ ì†ì„± ì¶”ê°€ ì‹œ ì—£ì§€ë§Œ ì¶”ê°€)
```

---

## 8. ì˜ˆì‹œ ìŠ¤íŠ¸ë¦¼

### 8.1 ê°„ë‹¨í•œ ì¿¼ë¦¬ ì˜ˆì‹œ

**ìì—°ì–´:**
```
"Aliceì™€ Bobì€ ì¹œêµ¬ì•¼?"
```

**GEUL Stream:**
```
// StreamHeader
[0x0000][0x0008]              // TypeId, Length
[0x4745][0x554C]              // Magic "GEUL"
[0x0100][0x0001]              // Version 1.0, Flags(TIDMAP)
[0x0000][0x0005]              // 5ê°œ íŒ¨í‚·

// TIDMAP Section
[0x0002][0x0004][0x0001][0x0003]  // Section: TIDMAP, 3 entries

// TID=1: Alice
[0x0001][0x0006][0x0001]
[0x0100][0x0000][0x0000][0x0001]

// TID=2: Bob
[0x0001][0x0006][0x0002]
[0x0100][0x0000][0x0000][0x0002]

// TID=3: RealWorld Context
[0x0001][0x0006][0x0003]
[0x0500][0x0000][0x0000][0x0100]

// Query Triple
[0x0200][0x0008]              // Triple
[0x0003]                       // Context: RealWorld
[0x0001]                       // Subject: Alice
[0x0000][0x0042]              // Property: Friend
[0x0002]                       // Object: Bob
[0x0000]                       // Reserved
```

**ì›Œë“œ ìˆ˜ ê³„ì‚°:**
```
Header: 8ì›Œë“œ
Section Marker: 4ì›Œë“œ
TIDMAP Entry Ã— 3: 6ì›Œë“œ Ã— 3 = 18ì›Œë“œ
Triple: 8ì›Œë“œ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ì´: 38ì›Œë“œ = 76 bytes
```

### 8.2 ë³µì¡í•œ ì˜ˆì‹œ: Event6

**ìì—°ì–´:**
```
"2020ë…„ 1ì›” 15ì¼, NYCì—ì„œ Aliceê°€ Bobì—ê²Œ ì±…ì„ ì£¼ì—ˆë‹¤"
```

**GEUL Stream:**
```
// Header (ìƒëµ)

// TIDMAP
TID=1: Alice
TID=2: Bob
TID=3: Book
TID=4: NYC
TID=5: 2020-01-15
TID=6: Give (í–‰ìœ„)
TID=7: Context (RealWorld)

// Event6
[0x0201][0x0010]              // Event6, 16ì›Œë“œ
[0x0007]                       // Context: RealWorld
[0x003F]                       // Presence: ëª¨ë“  í•„ë“œ
[0x0001]                       // Who: Alice
[0x0006]                       // What: Give
[0x0002]                       // Whom: Bob
[0x0005]                       // When: 2020-01-15
[0x0004]                       // Where: NYC
[0x0003]                       // Why: Book (gift)
[0x0000][0x0000][0x0000]      // Reserved
[0x0000][0x0000][0x0000]
```

### 8.3 Context ìƒì„¸ ì„œìˆ  ì˜ˆì‹œ

**ì„¤ì •:**
```
Context: "MCU 2012ë…„, í† ë‹ˆ ì‹œì , ê¸°ì–µ"
```

**GEUL Stream:**
```
// Context ë…¸ë“œ (ê°„ë‹¨)
[0x0101][0x0004][0x0010][0x0300]
  Context  4ì›Œë“œ   Ctx#10  Flags(MEMORY)

// Context ìƒì„¸ ì†ì„± (ì—£ì§€ë¡œ ì„œìˆ )

// 1. World ì†ì„±
[0x0200][0x0008]
[0x0010]                       // Context: Ctx#10 ìì‹ 
[0x0010]                       // Subject: Ctx#10
[0x0000][0x0001]              // Property: HAS_WORLD
[0x0011]                       // Object: MCU World
[0x0000]

// 2. Time ì†ì„±
[0x0200][0x0008]
[0x0010][0x0010]
[0x0000][0x0002]              // Property: HAS_TIME
[0x0012]                       // Object: Year 2012
[0x0000]

// 3. POV ì†ì„±
[0x0200][0x0008]
[0x0010][0x0010]
[0x0000][0x0003]              // Property: HAS_POV
[0x0001]                       // Object: Tony Stark
[0x0000]

// 4. ModalityëŠ” Flagsì— ì´ë¯¸ í¬í•¨ (0x0300 = MEMORY)
```

---

## 9. GPT í†µí•©

### 9.1 GPT Function Calling

```typescript
// GPT Function ì •ì˜
{
  "name": "gwms_query",
  "description": "Query WMS using GEUL stream",
  "parameters": {
    "type": "object",
    "properties": {
      "geul_stream": {
        "type": "array",
        "items": { "type": "integer" },
        "description": "16-bit word array"
      }
    }
  }
}

// GPT í˜¸ì¶œ ì˜ˆì‹œ
{
  "geul_stream": [
    0x0000, 0x0008, 0x4745, 0x554C,  // Header
    0x0100, 0x0001, 0x0000, 0x0005,
    0x0002, 0x0004, 0x0001, 0x0003,  // TIDMAP
    // ...
  ]
}
```

### 9.2 ìì—°ì–´ â†’ GEUL ë³€í™˜ ì˜ˆì‹œ

```
User: "ì•„ì´ì–¸ë§¨ì˜ ì¹œêµ¬ë“¤ì€?"

GPT ë‚´ë¶€ ì²˜ë¦¬:
1. ì—”í‹°í‹° ì¶”ì¶œ: "ì•„ì´ì–¸ë§¨"
2. ê´€ê³„ ì¶”ì¶œ: "ì¹œêµ¬"
3. GEUL ìƒì„±:
   - TIDMAP: ì•„ì´ì–¸ë§¨
   - Query: Triple(*, ì•„ì´ì–¸ë§¨, ì¹œêµ¬, ?)

GEUL Output:
[Header]
[TIDMAP: ì•„ì´ì–¸ë§¨=TID#1]
[Triple: Ctx=Any, Subj=TID#1, Prop=Friend, Obj=ANY]
```

### 9.3 GEUL â†’ ìì—°ì–´ ë³€í™˜ ì˜ˆì‹œ

```
WMS Result (GEUL):
[Header: 3 results]
[TIDMAP: 
  TID#1=í˜í¼ í¬ì¸ 
  TID#2=ì œì„ìŠ¤ ë¡œë””
  TID#3=í•´í”¼ í˜¸ê±´]
[Entity: TID#1]
[Entity: TID#2]
[Entity: TID#3]

GPT ì²˜ë¦¬:
1. TIDMAP íŒŒì‹±
2. Entity ë¦¬ìŠ¤íŠ¸ ì¶”ì¶œ
3. ìì—°ì–´ ìƒì„±

Output: "í˜í¼ í¬ì¸ , ì œì„ìŠ¤ ë¡œë””, í•´í”¼ í˜¸ê±´ì…ë‹ˆë‹¤."
```

---

## ë¶€ë¡ A: TypeId ì „ì²´ ëª©ë¡

```
Meta (0x00__)
â”œâ”€ 0x0000: StreamHeader
â”œâ”€ 0x0001: TIDMAP Entry
â”œâ”€ 0x0002: Section Marker
â””â”€ 0x00FF: Reserved

Node (0x01__)
â”œâ”€ 0x0100: Entity
â”œâ”€ 0x0101: Context
â”œâ”€ 0x0102: QuantitySpec
â””â”€ 0x01FF: Reserved

Edge (0x02__)
â”œâ”€ 0x0200: Triple
â”œâ”€ 0x0201: Event6
â”œâ”€ 0x0202: Relation
â””â”€ 0x02FF: Reserved

Primitive (0x03__)
â”œâ”€ 0x0300: Integer
â”œâ”€ 0x0301: Float
â”œâ”€ 0x0302: String
â””â”€ 0x03FF: Reserved

Reserved (0xFF__)
â””â”€ 0xFFFF: End Marker
```

---

## ë¶€ë¡ B: Property ID í‘œì¤€

```
ê¸€ë¡œë²Œ ì†ì„± (0x0000~0x0FFF):

Context ì†ì„±:
â”œâ”€ 0x0001: HAS_WORLD
â”œâ”€ 0x0002: HAS_TIME
â”œâ”€ 0x0003: HAS_POV
â””â”€ 0x0004: HAS_MODALITY

ê´€ê³„:
â”œâ”€ 0x0010: IS_A (instance_of)
â”œâ”€ 0x0011: PART_OF
â”œâ”€ 0x0042: FRIEND
â”œâ”€ 0x0043: ENEMY
â””â”€ ...

ì†ì„±:
â”œâ”€ 0x0100: HAS_NAME
â”œâ”€ 0x0101: HAS_AGE
â”œâ”€ 0x0102: HAS_HEIGHT
â””â”€ ...

ë™ì‚¬ (WordNet ê¸°ë°˜):
â”œâ”€ 0x1000~0x1FFF: ê¸°ë³¸ ë™ì‚¬
â””â”€ ...

ë„ë©”ì¸ ì „ìš© (0x2000~):
â”œâ”€ íŒíƒ€ì§€
â”œâ”€ ERP
â””â”€ ...
```

---

## ë¶€ë¡ C: ì„±ëŠ¥ íŠ¹ì„±

```
ì••ì¶•ë¥ :
- TID ì‚¬ìš© ì‹œ: 4ë°° (4ì›Œë“œ â†’ 1ì›Œë“œ)
- ì—”í‹°í‹° 100ê°œ ì°¸ì¡° ì‹œ:
  SIDX: 400ì›Œë“œ (800 bytes)
  TID: 100ì›Œë“œ + TIDMAP 600ì›Œë“œ = 700ì›Œë“œ
  ì ˆê°: 100ì›Œë“œ (200 bytes, 25%)

íŒŒì‹± ì†ë„:
- ì›Œë“œ ë‹¨ìœ„ ì½ê¸°: O(1)
- TIDMAP êµ¬ì¶•: O(N) (N=ì—”í‹°í‹° ìˆ˜)
- ì „ì²´ íŒŒì‹±: O(M) (M=íŒ¨í‚· ìˆ˜)

ë©”ëª¨ë¦¬:
- ì›Œë“œë‹¹ 2 bytes
- ì „í˜•ì  ì¿¼ë¦¬: 100~1000ì›Œë“œ (200~2000 bytes)
- GPT ì»¨í…ìŠ¤íŠ¸: 1ì›Œë“œ â‰ˆ 1í† í°
```

---

## ë¶€ë¡ D: í™•ì¥ ê°€ëŠ¥ì„±

### ë¯¸ë˜ ì¶”ê°€ íƒ€ì…

```
Node:
â”œâ”€ 0x0103: Rule (ê·œì¹™)
â”œâ”€ 0x0104: Constraint (ì œì•½)
â””â”€ 0x0105: Pattern (íŒ¨í„´)

Edge:
â”œâ”€ 0x0203: Causality (ì¸ê³¼)
â”œâ”€ 0x0204: Temporal (ì‹œê°„ ê´€ê³„)
â””â”€ 0x0205: Spatial (ê³µê°„ ê´€ê³„)

Primitive:
â”œâ”€ 0x0303: Boolean
â”œâ”€ 0x0304: DateTime
â””â”€ 0x0305: Vector
```

### ë²„ì „ ê´€ë¦¬

```
Version í•„ë“œ (16-bit):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Major  â”‚ Minor  â”‚
â”‚ 8 bits â”‚ 8 bits â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

v1.0 = 0x0100
v1.5 = 0x0105
v2.0 = 0x0200

í•˜ìœ„ í˜¸í™˜:
- Major ë³€ê²½: í˜¸í™˜ ë¶ˆê°€
- Minor ë³€ê²½: í•˜ìœ„ í˜¸í™˜
```

---

## ê²°ë¡ 

### í•µì‹¬ ì„¤ê³„ ì›ì¹™

```
1. 16-bit ì›Œë“œ = ëª¨ë“  ê²ƒì˜ ê¸°ë³¸ ë‹¨ìœ„
2. 4ì›Œë“œ ê³ ì • = ë…¸ë“œì˜ í‘œì¤€ í¬ê¸°
3. TID ì••ì¶• = ì°¸ì¡° íš¨ìœ¨í™”
4. ì—£ì§€ ì„œìˆ  = Context ìƒì„¸ ì •ë³´
5. GPT í†µí•© = í† í° ìŠ¤íŠ¸ë¦¼ ì§ì ‘ ë§¤í•‘
```

### GEULì˜ ìœ„ì¹˜

```
GEULì€:
âœ… GPT-WMS ì¸í„°í˜ì´ìŠ¤ ì–¸ì–´
âœ… 16-bit ì›Œë“œ ê¸°ë°˜ ìŠ¤íŠ¸ë¦¼
âœ… ëª…í™•ì„±ê³¼ ì••ì¶•ì˜ ê· í˜•
âœ… GPT í† í°í™” ê°€ëŠ¥

GEULì´ ì•„ë‹Œ ê²ƒ:
âŒ WMS ë‚´ë¶€ ì €ì¥ í¬ë§·
âŒ ìì—°ì–´ ëŒ€ì²´ ì–¸ì–´
âŒ ë²”ìš© ë°ì´í„° í¬ë§·
```

### êµ¬í˜„ ìš°ì„ ìˆœìœ„

```
Phase 1: ê¸°ë³¸ ìŠ¤íŠ¸ë¦¼ (Week 1-2)
â–¡ TypeId ì²´ê³„ êµ¬í˜„
â–¡ StreamHeader
â–¡ TIDMAP
â–¡ Entity/Context ë…¸ë“œ
â–¡ Triple ì—£ì§€

Phase 2: ì¸ì½”ë”/ë””ì½”ë” (Week 3-4)
â–¡ TID í• ë‹¹ ë¡œì§
â–¡ SIDX â†’ TID ì••ì¶•
â–¡ GEUL â†’ ë‚´ë¶€ í¬ë§· ë³€í™˜
â–¡ ë‚´ë¶€ í¬ë§· â†’ GEUL ë³€í™˜

Phase 3: GPT í†µí•© (Week 5-6)
â–¡ Function Calling ì¸í„°í˜ì´ìŠ¤
â–¡ ìì—°ì–´ â†’ GEUL ë³€í™˜ í”„ë¡¬í”„íŠ¸
â–¡ GEUL â†’ ìì—°ì–´ ë³€í™˜ í”„ë¡¬í”„íŠ¸
â–¡ E2E í…ŒìŠ¤íŠ¸
```

---

## ë¶€ë¡ E: ì‹¤ì œ êµ¬í˜„ ì˜ˆì‹œ

### E.1 Go êµ¬ì¡°ì²´

```go
// core/geul/types.go

package geul

// WordëŠ” 16-bit ê¸°ë³¸ ë‹¨ìœ„
type Word uint16

// Streamì€ ì›Œë“œ ë°°ì—´
type Stream []Word

// TypeId ì •ì˜
const (
    // Meta
    TYPE_STREAM_HEADER TypeId = 0x0000
    TYPE_TIDMAP_ENTRY  TypeId = 0x0001
    TYPE_SECTION       TypeId = 0x0002
    
    // Node
    TYPE_ENTITY        TypeId = 0x0100
    TYPE_CONTEXT       TypeId = 0x0101
    TYPE_QUANTITY_SPEC TypeId = 0x0102
    
    // Edge
    TYPE_TRIPLE        TypeId = 0x0200
    TYPE_EVENT6        TypeId = 0x0201
)

type TypeId Word

// Packet ì¸í„°í˜ì´ìŠ¤
type Packet interface {
    TypeId() TypeId
    Length() int // ì›Œë“œ ìˆ˜
    Encode() Stream
}

// Entity íŒ¨í‚·
type EntityPacket struct {
    TID   Word
    Flags Word
}

func (e *EntityPacket) TypeId() TypeId { 
    return TYPE_ENTITY 
}

func (e *EntityPacket) Length() int { 
    return 4 
}

func (e *EntityPacket) Encode() Stream {
    return Stream{
        Word(TYPE_ENTITY),
        Word(0x0004),
        e.TID,
        e.Flags,
    }
}

// Context íŒ¨í‚·
type ContextPacket struct {
    TID   Word
    Flags Word
}

func (c *ContextPacket) TypeId() TypeId { 
    return TYPE_CONTEXT 
}

func (c *ContextPacket) Length() int { 
    return 4 
}

func (c *ContextPacket) Encode() Stream {
    return Stream{
        Word(TYPE_CONTEXT),
        Word(0x0004),
        c.TID,
        c.Flags,
    }
}

// Triple íŒ¨í‚·
type TriplePacket struct {
    CtxTID  Word
    SubjTID Word
    PropId  uint32  // 2ì›Œë“œ
    ObjTID  Word
}

func (t *TriplePacket) TypeId() TypeId { 
    return TYPE_TRIPLE 
}

func (t *TriplePacket) Length() int { 
    return 8 
}

func (t *TriplePacket) Encode() Stream {
    return Stream{
        Word(TYPE_TRIPLE),
        Word(0x0008),
        t.CtxTID,
        t.SubjTID,
        Word(t.PropId >> 16),    // PropId ìƒìœ„
        Word(t.PropId & 0xFFFF), // PropId í•˜ìœ„
        t.ObjTID,
        0x0000, // Reserved
    }
}
```

### E.2 TIDMAP ê´€ë¦¬

```go
// core/geul/tidmap.go

type TIDMap struct {
    tidToSIDX map[Word]SIDX
    midToTID map[SIDX]Word
    nextTID  Word
}

func NewTIDMap() *TIDMap {
    return &TIDMap{
        tidToSIDX: make(map[Word]SIDX),
        midToTID: make(map[SIDX]Word),
        nextTID:  1, // 0ì€ NULL ì˜ˆì•½
    }
}

func (tm *TIDMap) Register(mid SIDX) Word {
    // ì´ë¯¸ ë“±ë¡ëœ ê²½ìš°
    if tid, exists := tm.midToTID[mid]; exists {
        return tid
    }
    
    // ìƒˆë¡œ ë“±ë¡
    tid := tm.nextTID
    tm.nextTID++
    
    if tm.nextTID == 0 {
        panic("TID overflow (65535 limit)")
    }
    
    tm.tidToSIDX[tid] = mid
    tm.midToTID[mid] = tid
    
    return tid
}

func (tm *TIDMap) Resolve(tid Word) (SIDX, bool) {
    mid, ok := tm.tidToSIDX[tid]
    return mid, ok
}

func (tm *TIDMap) Encode() Stream {
    var stream Stream
    
    // Section Marker
    stream = append(stream,
        Word(TYPE_SECTION),
        0x0004,
        0x0001, // TIDMAP section
        Word(len(tm.tidToSIDX)), // Entry count
    )
    
    // Entries
    for tid, mid := range tm.tidToSIDX {
        entry := EncodeTIDMapEntry(tid, mid)
        stream = append(stream, entry...)
    }
    
    return stream
}

func EncodeTIDMapEntry(tid Word, mid SIDX) Stream {
    return Stream{
        Word(TYPE_TIDMAP_ENTRY),
        0x0006,  // 6ì›Œë“œ
        tid,
        Word(mid >> 48),
        Word((mid >> 32) & 0xFFFF),
        Word((mid >> 16) & 0xFFFF),
        Word(mid & 0xFFFF),
    }
}
```

### E.3 ìŠ¤íŠ¸ë¦¼ ë¹Œë”

```go
// core/geul/builder.go

type StreamBuilder struct {
    tidmap  *TIDMap
    packets []Packet
}

func NewStreamBuilder() *StreamBuilder {
    return &StreamBuilder{
        tidmap:  NewTIDMap(),
        packets: []Packet{},
    }
}

// Entity ì¶”ê°€
func (sb *StreamBuilder) AddEntity(mid SIDX, flags Word) {
    tid := sb.tidmap.Register(mid)
    
    packet := &EntityPacket{
        TID:   tid,
        Flags: flags,
    }
    
    sb.packets = append(sb.packets, packet)
}

// Context ì¶”ê°€
func (sb *StreamBuilder) AddContext(mid SIDX, flags Word) {
    tid := sb.tidmap.Register(mid)
    
    packet := &ContextPacket{
        TID:   tid,
        Flags: flags,
    }
    
    sb.packets = append(sb.packets, packet)
}

// Triple ì¶”ê°€
func (sb *StreamBuilder) AddTriple(
    ctxSIDX, subjSIDX, objSIDX SIDX,
    propId uint32,
) {
    ctxTID := sb.tidmap.Register(ctxSIDX)
    subjTID := sb.tidmap.Register(subjSIDX)
    objTID := sb.tidmap.Register(objSIDX)
    
    packet := &TriplePacket{
        CtxTID:  ctxTID,
        SubjTID: subjTID,
        PropId:  propId,
        ObjTID:  objTID,
    }
    
    sb.packets = append(sb.packets, packet)
}

// ìµœì¢… ìŠ¤íŠ¸ë¦¼ ìƒì„±
func (sb *StreamBuilder) Build() Stream {
    var stream Stream
    
    // 1. Header
    header := sb.buildHeader()
    stream = append(stream, header...)
    
    // 2. TIDMAP
    tidmapStream := sb.tidmap.Encode()
    stream = append(stream, tidmapStream...)
    
    // 3. Packets
    for _, packet := range sb.packets {
        encoded := packet.Encode()
        stream = append(stream, encoded...)
    }
    
    return stream
}

func (sb *StreamBuilder) buildHeader() Stream {
    packetCount := len(sb.packets) + 
                   len(sb.tidmap.tidToSIDX) + 
                   2 // Header + Section Marker
    
    return Stream{
        Word(TYPE_STREAM_HEADER),
        0x0008, // 8ì›Œë“œ
        0x4745, // "GE"
        0x554C, // "UL"
        0x0100, // v1.0
        0x0001, // Flags: HAS_TIDMAP
        Word(packetCount >> 16),
        Word(packetCount & 0xFFFF),
    }
}
```

### E.4 íŒŒì„œ

```go
// core/geul/parser.go

type Parser struct {
    stream Stream
    pos    int
    tidmap *TIDMap
}

func NewParser(stream Stream) *Parser {
    return &Parser{
        stream: stream,
        pos:    0,
        tidmap: NewTIDMap(),
    }
}

func (p *Parser) Parse() error {
    // 1. Header
    if err := p.parseHeader(); err != nil {
        return err
    }
    
    // 2. Sections
    for p.pos < len(p.stream) {
        typeId := TypeId(p.stream[p.pos])
        
        switch typeId {
        case TYPE_SECTION:
            if err := p.parseSection(); err != nil {
                return err
            }
            
        case TYPE_ENTITY:
            if err := p.parseEntity(); err != nil {
                return err
            }
            
        case TYPE_CONTEXT:
            if err := p.parseContext(); err != nil {
                return err
            }
            
        case TYPE_TRIPLE:
            if err := p.parseTriple(); err != nil {
                return err
            }
            
        default:
            return fmt.Errorf("unknown type: 0x%04X", typeId)
        }
    }
    
    return nil
}

func (p *Parser) parseHeader() error {
    if p.pos+8 > len(p.stream) {
        return errors.New("header too short")
    }
    
    typeId := TypeId(p.stream[p.pos])
    if typeId != TYPE_STREAM_HEADER {
        return errors.New("invalid header")
    }
    
    magic := (uint32(p.stream[p.pos+2]) << 16) | 
             uint32(p.stream[p.pos+3])
    
    if magic != 0x4745554C { // "GEUL"
        return errors.New("invalid magic")
    }
    
    p.pos += 8
    return nil
}

func (p *Parser) parseSection() error {
    // [TypeId][Length][SectionId][Count]
    sectionId := p.stream[p.pos+2]
    
    if sectionId == 0x0001 { // TIDMAP
        return p.parseTIDMap()
    }
    
    return errors.New("unknown section")
}

func (p *Parser) parseTIDMap() error {
    count := int(p.stream[p.pos+3])
    p.pos += 4
    
    for i := 0; i < count; i++ {
        // [TypeId][Length][TID][SIDX-4ì›Œë“œ]
        tid := p.stream[p.pos+2]
        
        mid := SIDX(p.stream[p.pos+3])<<48 |
               SIDX(p.stream[p.pos+4])<<32 |
               SIDX(p.stream[p.pos+5])<<16 |
               SIDX(p.stream[p.pos+6])
        
        p.tidmap.tidToSIDX[tid] = mid
        p.tidmap.midToTID[mid] = tid
        
        p.pos += 7
    }
    
    return nil
}

func (p *Parser) parseEntity() error {
    // [TypeId][Length][TID][Flags]
    tid := p.stream[p.pos+2]
    flags := p.stream[p.pos+3]
    
    mid, ok := p.tidmap.Resolve(tid)
    if !ok {
        return fmt.Errorf("unresolved TID: 0x%04X", tid)
    }
    
    // Entity ì²˜ë¦¬ ë¡œì§
    log.Printf("Entity: SIDX=0x%016X, Flags=0x%04X", mid, flags)
    
    p.pos += 4
    return nil
}
```

---

## ë¶€ë¡ F: ì‚¬ìš© ì˜ˆì‹œ (ì „ì²´ í”Œë¡œìš°)

```go
package main

import (
    "fmt"
    "gwms/core/geul"
)

func main() {
    // 1. WMS ì¿¼ë¦¬ ê²°ê³¼ (ë‚´ë¶€ í¬ë§·)
    results := []struct {
        SIDX   SIDX
        Name  string
        Flags uint32
    }{
        {0x0100000000000001, "Alice", 0x0201},
        {0x0100000000000002, "Bob", 0x0102},
        {0x0100000000000003, "Carol", 0x0001},
    }
    
    ctxSIDX := SIDX(0x0500000000000100) // RealWorld
    
    // 2. GEUL Stream ìƒì„±
    builder := geul.NewStreamBuilder()
    
    // Context ì¶”ê°€
    builder.AddContext(ctxSIDX, 0x0100)
    
    // Entityë“¤ ì¶”ê°€
    for _, r := range results {
        builder.AddEntity(r.SIDX, Word(r.Flags))
    }
    
    // Triple ì¶”ê°€ (Alice-Friend-Bob)
    builder.AddTriple(
        ctxSIDX,
        results[0].SIDX, // Alice
        results[1].SIDX, // Bob
        0x0042,         // Friend
    )
    
    // 3. ë¹Œë“œ
    stream := builder.Build()
    
    // 4. ì¶œë ¥ (GPTë¡œ ì „ì†¡ ê°€ëŠ¥)
    fmt.Printf("GEUL Stream (%d words):\n", len(stream))
    for i, word := range stream {
        if i%8 == 0 {
            fmt.Printf("\n[%04d] ", i)
        }
        fmt.Printf("%04X ", word)
    }
    fmt.Println()
    
    // 5. íŒŒì‹± (ì—­ë°©í–¥)
    parser := geul.NewParser(stream)
    if err := parser.Parse(); err != nil {
        panic(err)
    }
    
    fmt.Println("Parse success!")
}
```

**ì¶œë ¥:**
```
GEUL Stream (42 words):
[0000] 0000 0008 4745 554C 0100 0001 0000 002A
[0008] 0002 0004 0001 0004 0001 0007 0001 0100
[0016] 0000 0000 0000 0001 0001 0007 0002 0100
[0024] 0000 0000 0000 0002 0001 0007 0003 0100
[0032] 0000 0000 0000 0003 0001 0007 0004 0500
[0040] 0000 0000 0000 0100 0101 0004 0004 0100
[0048] 0100 0004 0001 0201 0100 0004 0002 0102
[0056] 0100 0004 0003 0001 0200 0008 0004 0001
[0064] 0000 0042 0002 0000

Parse success!
```

---

## ë¶€ë¡ G: ìµœì í™” íŒ

### G.1 TID ì¬ì‚¬ìš©

```go
// ìì£¼ ì‚¬ìš©ë˜ëŠ” ì—”í‹°í‹°ë§Œ TID í• ë‹¹
type SmartTIDMap struct {
    *TIDMap
    refCount map[SIDX]int
}

func (stm *SmartTIDMap) ShouldRegister(mid SIDX) bool {
    // 2íšŒ ì´ìƒ ì°¸ì¡°ë  ê²ƒ ê°™ìœ¼ë©´ TID í• ë‹¹
    return stm.refCount[mid] >= 2
}
```

### G.2 ìŠ¤íŠ¸ë¦¼ ì••ì¶•

```go
// zstd ì••ì¶• (ì›Œë“œ ë‹¨ìœ„ëŠ” ìœ ì§€)
func CompressStream(stream Stream) []byte {
    // Stream â†’ bytes
    buf := make([]byte, len(stream)*2)
    for i, word := range stream {
        binary.LittleEndian.PutUint16(buf[i*2:], uint16(word))
    }
    
    // zstd ì••ì¶•
    compressed := zstd.Compress(buf)
    return compressed
}
```

### G.3 ë°°ì¹˜ ì²˜ë¦¬

```go
// ì—¬ëŸ¬ ì¿¼ë¦¬ ê²°ê³¼ë¥¼ í•œ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ
builder := geul.NewStreamBuilder()

for _, query := range queries {
    results := gwms.Execute(query)
    
    for _, result := range results {
        builder.AddEntity(result.SIDX, result.Flags)
    }
}

stream := builder.Build()
```

---

## ìµœì¢… ìš”ì•½

### GEUL ìŠ¤íŠ¸ë¦¼ì˜ í•µì‹¬

```
1. 16-bit ì›Œë“œ = ëª¨ë“  ê²ƒì˜ ê¸°ë³¸ ë‹¨ìœ„
   - GPT í† í°ê³¼ 1:1 ë§¤í•‘ ê°€ëŠ¥
   - íŒŒì‹± ë‹¨ìˆœ

2. 4ì›Œë“œ ë…¸ë“œ = í‘œì¤€ í¬ê¸°
   - Entity, Context, QuantitySpec ëª¨ë‘ 4ì›Œë“œ
   - ë©”ëª¨ë¦¬ ì •ë ¬ íš¨ìœ¨

3. TID ì••ì¶• = ì°¸ì¡° ìµœì í™”
   - 4ì›Œë“œ SIDX â†’ 1ì›Œë“œ TID
   - 65,535ê°œê¹Œì§€ ì••ì¶•

4. ì—£ì§€ ì„œìˆ  = ìƒì„¸ ì •ë³´ ë¶„ë¦¬
   - Context ë…¸ë“œëŠ” 4ì›Œë“œë¡œ ê°„ë‹¨
   - ìƒì„¸(world, time, pov)ëŠ” Tripleë¡œ
   - í™•ì¥ ìš©ì´

5. ìê¸° ê¸°ìˆ ì  = íƒ€ì… ëª…ì‹œ
   - ëª¨ë“  íŒ¨í‚·ì— TypeId
   - ë²„ì „ ê´€ë¦¬ ê°€ëŠ¥
   - íŒŒì„œ robust
```

### ë‹¤ìŒ ë‹¨ê³„

```
â–¡ GEUL ì¸ì½”ë”/ë””ì½”ë” êµ¬í˜„
â–¡ WMS ì¿¼ë¦¬ ê²°ê³¼ â†’ GEUL ë³€í™˜
â–¡ GPT Function Calling í†µí•©
â–¡ E2E í…ŒìŠ¤íŠ¸
â–¡ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
```

**ì´ ëª…ì„¸ì„œë¡œ GEUL êµ¬í˜„ì„ ì‹œì‘í•˜ì„¸ìš”! ğŸš€**

---

**ë¬¸ì„œ ë**
