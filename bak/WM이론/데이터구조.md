## 1. GWMS 최상위: World

* RDBMS의 “DB”에 해당하는 단위가 **World**.
* 파일 하나 ≒ World 하나.
* 예:

  * `wikidata.world`
  * `reality_2025.world`
  * `novel_ironman.world`
* World 메타에는 최소한:

  * `world_id`
  * `truth_mode`

    * `FICTION_CANON` : 작가 월드 (AUTHOR POV는 정의상 참)
    * `REAL_ASSERTED`: 현실 월드 (항상 가설/합의 상태)
  * 버전/타임스탬프/설명 정도.

---

## 2. ID 체계

### 1) SIDX (Meaning ID, 64bit)

* **모든 엔티티/컨텍스트/동사의 기본 ID**.
* 구조(개념적으로):

  * 상위 비트: 도메인/타입/역할/POV/세계선 등 의미 정렬 비트
  * 하위 8bit 정도: 충돌 방지/여유
* 장점:

  * “대통령 역할”, “지구667”, “기독교 세계관” 같은 걸
    **비트마스크로 빠르게 필터** 가능.

### 2) EID (Existence ID)

* “이 사람은 이 사람이다” 같은 **존재 동일성 ID** (옵션).
* 한 EID에 대해, 시대/역할/상태에 따라 **여러 SIDX 프로필**이 달라질 수 있음.

  * 예: 머스크가 나중에 대통령 되면 대통령 상태용 SIDX 추가.

### 3) TID (Temporary ID, 16bit)

* **GWMS 내부에는 저장 안 함.**
* GEUL/GPT 입출력용:

  * 쿼리 결과에서 등장한 SIDX들만 모아
  * `TID → SIDX` 맵핑 만들어서 1워드(16bit)로 압축.
* GWMS ↔ GEUL 브릿지에서만 사용.

---

## 3. Entity 구조 (컨텍스트/동사 포함)

### 1) Entity 버킷

* World 안의 엔티티는 전부 **Entity**로 통일.

* 내부 저장:

  * SIDX 상위 4~8비트로 **버킷 분할**:

    ```text
    0x0? : PERSON
    0x1? : ORG
    0x2? : PLACE
    0x3? : WORK(작품)
    0x4? : EVENT/ABSTRACT
    0x5? : CONTEXT
    0x6? : VERB / PROPERTY
    0x7? : QUANTITY_SPEC / UNIT
    ...
    ```

* 각 버킷은 SoA 형태:

  ```go
  type EntityBucket struct {
      SIDXs  []uint64
      Meta  []uint32  // ObjectType, flags 등
      // 필요시 추가 컬럼
  }
  ```

### 2) Context = Entity의 한 종류

* 별도 구조 아님, 그냥 `ObjectType=CONTEXT`인 엔티티.
* CTXSIDX에 논리적으로 포함되는 것:

  * world (어느 World인지)
  * time/scene (연도, 장면, 타임라인 좌표)
  * POV (개인 시점, 이념/세계관, 내레이터 시점 등)
  * modality (REAL / MEMORY / BELIEF / RUMOR / WHAT_IF …)

### 3) Verb/Property = Entity의 한 종류

* 동사/속성도 `VERB`/`PROPERTY` 버킷에 들어가는 엔티티.
* 기본 동사는 **WordNet verb synset 기반 글로벌 VERB**로 스타트.
* 로컬 World 전용 동사도 SIDX 상위 비트로 scope 구분해서 추가.

### 4) QuantitySpec(물리량 스펙)도 Entity

* “물리량 노드” 따로 안 두고, `ObjectType=QUANTITY_SPEC`인 엔티티로 처리.
* 안에 들어가는 정보:

  * 정수/부동, 부호 여부
  * 비트 폭 카테고리(16/32/48/64 등)
  * 단위(m, s, kg, HP, USD…)
  * 스케일(고정 소수점 배율)
  * 표시 형식/범위 등.

---

## 4. Edge 구조

### 1) Edge 헤더 (16bit)

* 1워드(16bit) 헤더:

  ```text
  bit0 : Node/Edge  (1 = Edge)
  bit1 : Verb/Edge  (0 = 동사 정의, 1 = 관계/사건 엣지)
  bit2-15 : EdgeType (14bit)
  ```

* `EdgeType` 14bit는 이렇게 쪼갬:

  ```text
  EdgeType = [ 상위 8bit: FAMILY_ID ][ 하위 6bit: FAMILY_LOCAL_BITS ]
  ```

  * `FAMILY_ID`에 따라 하위 6비트 의미가 달라짐.

### 2) 주요 FAMILY 예시

* `FAMILY_TRIPLE` : 일반 Triple 엣지

  * 하위 6bit: Triple 서브타입/옵션
* `FAMILY_EVENT6` : 6하원칙 사건 엣지

  * 하위 6bit = **who/what/whom/when/where/why presence 비트마스크**
* `FAMILY_EDGE4/5` : 4항/5항 엣지 필요 시

  * 하위 6bit 중 일부를 presence, 나머지는 옵션으로 사용
* `FAMILY_META` : 메타/링크/Keyframe용 등

### 3) Triple Edge (3항)

* 논리 구조:

  * `(ctx_mid, subj_mid, prop_id, obj_mid or value64)`

* 내부 SoA 예:

  ```go
  type TripleStore struct {
      Ctx   []uint64
      Subj  []uint64
      Obj   []uint64   // SIDX or 값슬롯 해석용
      Prop  []uint32   // prop_id, prop_id → verb_mid/QuantitySpec 등으로 해석
  }
  ```

* Wikidata Triple → 이 Triple로 매핑.

### 4) Event6 Edge (6하원칙)

* **항은 항상 6개 고정**, presence는 EdgeType 하위 6비트로 표현.

  ```go
  type Event6Store struct {
      Ctx   []uint64
      Who   []uint64
      What  []uint64
      Whom  []uint64
      When  []uint64
      Where []uint64
      Why   []uint64
      // EdgeType에서 FAMILY_EVENT6 + presence mask 추출
  }
  ```

* presence 비트:

  * bit0: who, bit1: what, …, bit5: why
  * 1이면 “의미 있는 값 있음”, 0이면 “미정/해당 없음”.

* SIDX=0은 그냥 padding;
  **실제 의미 여부는 presence 비트가 결정**.

### 5) 다른 arity Edge (4/5항)

* 필요하면 `Edge4Store`, `Edge5Store` 같은 SoA 배열을 별도 유지.
* 각 FAMILY에서:

  * 하위 6비트를 arg1~argN presence + 옵션으로 사용.

---

## 5. 값(물리량) 처리

* 물리량은 **별도 Node 타입 없음**, 전부:

  * `QuantitySpec` 엔티티 + 엣지의 64bit 값 슬롯 조합으로 표현.
* Property 메타:

  * `prop_id → quantity_spec_mid`로 연결.
* Edge 값 슬롯:

  * 64bit `value64` 안에 숫자만 저장.
  * 해석은 QuantitySpec/Property 보고 결정:

    * 정수/부동/고정소수
    * 단위/스케일 등.

---

## 6. 물리 저장 구조 요약

World 파일 내부적으로:

1. **Entity 영역**

   * SIDX 상위 4~8비트로 버킷킹된 `EntityBucket[]`
   * Context/Verb/QuantitySpec 전부 Entity의 일부 버킷.

2. **Edge 영역**

   * arity + FAMILY 기준으로 SoA 분할:

     * `TripleStore` (3항)
     * `Event6Store`
     * 필요시 `Edge4Store`, `Edge5Store` …
   * 각 Store는 `Ctx/Subj/...` 컬럼 배열.

3. **보조 인덱스**

   * SIDX → EntityBucket 위치
   * prop_id → Property 메타/Verb SIDX/QuantitySpec 등
   * 쿼리 성능용 인덱스는 나중에 (파일럿은 선형 스캔+비트연산).

---

## 7. GEUL / GPT와의 연결 (간단 요약)

* GWMS 내부:

  * **항상 SIDX 64bit** 기준으로 노드/엣지 관리.
* GEUL 스트림/GPT 컨텍스트:

  * 상단 TIDMAP에서 `TID (16bit) → SIDX` 매핑
  * Node/Edge는 전부 TID로 서로를 참조
  * 덕분에:

    * 3항 엣지 기준

      * GWMS: SIDX 4개 수준 (헤더+컨텍스트 포함 16워드)
      * GEUL 압축: TID 기준 6워드 정도까지 축소 가능.

---

요 정도가 **GWMS 내부에서 World가 어떻게 구성되는지, 그리고 Entity/Context/Edge가 어떻게 배치되는지**에 대한 현재 정리본이라고 보면 될 것 같아.
(규칙 GEUL/서술 GEUL은 이 위에 올라가는 상위 레이어고, GWMS는 일단 여기까지가 코어 구조.)
