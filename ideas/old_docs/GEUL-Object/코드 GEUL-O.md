# **코드 글오 (Code GEUL-O)**

## 1\. 정의 (Definition)

\*\*`코드 글오(Code GEUL-O)`\*\*는 SEGLAM 아키텍처 내에서 **절대적인 정밀성**이나 **외부 세계와의 상호작용**이 요구되는 절차적 지식(Procedural Knowledge)을 담는 특수 목적 객체입니다. 이는 AI의 통계적 추론이 아닌, CPU나 외부 API와 같은 결정론적 실행 엔진(Deterministic Execution Engine)에 의해 수행될 \*\*'실행 가능한 코드'\*\*를 표현합니다.

`코드 글오`는 SEGLAM이 단순한 정보 검색기를 넘어, 정밀한 계산, 파일 시스템 접근, 외부 서비스 호출 등 실제적인 작업을 수행하는 강력한 \*\*'에이전트(Agent)'\*\*가 될 수 있도록 하는 핵심적인 도구입니다.

## 2\. 핵심 철학: 추론과 실행의 명확한 분리

`코드 글오`의 존재 이유는 SEGLAM 아키텍처의 핵심 철학인 \*\*'추론과 실행의 분리'\*\*에 있습니다.

  * **추론 (Reasoning)**: `추론 GAT`의 영역입니다. `연결 글오`에 담긴 '규칙'을 해석하여 유연하고 통계적인 판단을 내리는 역할입니다. (예: "날씨가 추울 것 같으니, 외투를 입는 것이 좋겠다.")
  * **실행 (Execution)**: \*\*`코드 글오`\*\*의 영역입니다. 1+1=2와 같이 오차가 허용되지 않는 계산이나, 특정 URL에 HTTP 요청을 보내는 것과 같이 실제 세계에 영향을 미치는 명확한 작업을 수행하는 역할입니다.

`추론 GAT`는 `코드 글오`를 만나면, 그 내용을 직접 이해하려 하지 않고, 가장 적합한 외부 실행 엔진에 작업을 \*\*위임(delegate)\*\*하고 결과만 돌려받습니다. 이는 마치 CEO가 회계 계산을 직접 하지 않고 회계팀에 위임하는 것과 같습니다.

## 3\. 구조: GEUL 바이트코드 (GEUL Bytecode)

`코드 글오`의 내용은 **'GEUL 바이트코드'** 라는 단순하고 안전한 명령어 집합으로 표현됩니다. 이는 Java 바이트코드나 Python 바이트코드와 유사한 개념으로, 특정 하드웨어나 OS에 종속되지 않는 가상 머신(VM)에서 실행되도록 설계되었습니다.

  * **설계 원칙**:
      * **단순성**: 255개 미만의 단순한 명령어로 구성됩니다. (예: `PUSH`, `ADD`, `CALL_API`)
      * **안전성 (Sandboxed)**: 파일 시스템의 특정 디렉토리나 네트워크의 특정 주소에만 접근할 수 있도록 제한된 환경(Sandbox)에서 실행되어 시스템의 안정성을 보장합니다.
      * **효율성**: INT8 환경에서도 완벽한 정확성을 보장하며, 매우 빠르고 가볍게 실행되도록 설계되었습니다.

### 3.1. 핵심 구성 글소 (Core GEUL-SO Packets)

| 글소(GEUL-SO) 이름 | 핵심 역할 | 바디(Body) 내용 | 비고 |
| :--- | :--- | :--- | :--- |
| **코드 타입**\<br\>(CodeType) | 코드의 실행 환경이나 종류를 지정합니다. | `GEUL_Bytecode_v1`, `Python_v3.9`, `SQL_PostgreSQL` 등 실행 환경을 가리키는 **벡터 식별자**. | 이를 통해 올바른 실행 엔진에 코드를 전달합니다. |
| **입력 명세**\<br\>(InputSpec) | 코드가 실행되기 위해 필요한 입력 파라미터의 이름과 타입을 정의합니다. | `[ {name: "x", type: "Integer"}, {name: "y", type: "Integer"} ]`와 같은 구조화된 데이터. | |
| **출력 명세**\<br\>(OutputSpec) | 코드가 실행된 후 반환할 결과의 이름과 타입을 정의합니다. | `[ {name: "result", type: "Integer"} ]`와 같은 구조화된 데이터. | |
| **코드 본문**\<br\>(CodeBody) | 실제 실행될 명령어의 순차적인 나열입니다. | GEUL 바이트코드의 바이너리 시퀀스. | |

## 4\. 종합 예시: "두 숫자를 더하는 함수"

#### **자연어 요청**: "x와 y를 더하는 절차"

#### **`코드 글오` 표현**:

```yaml
ObjectID: Code_Add_Function_ID
GEUL_O_Type: Code_GEUL-O

Packets:
  - CodeType: "GEUL_Bytecode_v1_ID"
  
  - InputSpec:
      - Parameter_1: { name: "x", type: "Integer_ID" }
      - Parameter_2: { name: "y", type: "Integer_ID" }
      
  - OutputSpec:
      - ReturnValue: { name: "sum", type: "Integer_ID" }
      
  - CodeBody: # (의사코드)
      - PUSH_PARAM "x"  # 파라미터 x를 스택에 올림
      - PUSH_PARAM "y"  # 파라미터 y를 스택에 올림
      - ADD             # 스택 위의 두 숫자를 더함
      - RETURN "sum"    # 결과를 sum이라는 이름으로 반환
```

## 5\. 아키텍처 내에서의 역할

`추론 GAT`가 "3과 5를 더해야 한다"는 결론에 도달하면, WMS에서 위 `코드 글오`를 검색합니다. 그리고 `x=3`, `y=5`를 입력값으로 GEUL 바이트코드 실행 엔진에 이 코드를 전달합니다. 실행 엔진이 `sum=8`이라는 결과를 반환하면, GAT는 이 결과를 받아 다음 추론 단계에 사용합니다.

이처럼 `코드 글오`는 SEGLAM이 유연한 추론 능력과 정밀한 실행 능력을 모두 갖춘, 완전한 AI 에이전트로 작동하기 위한 필수적인 구성요소입니다.