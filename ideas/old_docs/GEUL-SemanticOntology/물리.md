# 물리 GEUL-SO (Units/Quantity GEUL-SO)

## 0. 설계 목표

- **정밀 보존형**: 8비트 전송/저장 제약이 있어도, **다차원 분산(4D/8D)**로 32/64비트 유효비트를 보존
- **우아한 열화형**: 목적에 따라 정밀도 열화 허용 시, 상위 의미(단위·크기 스케일·부호 등)만 유지하며 자연스럽게 수렴
- **표준 단위 준수**: SI/ISO/IEC 80000 등 권위기관 기준을 그대로 사용(Authority 매핑)
- **변환은 테이블**: 단위변환은 고정 상수(Conversion Matrix)로 제공

## 1. 패킷 유형

| 유형 | 목적 | 특징 |
|------|------|------|
| **Q-Precise** | 정밀 보존형 | 4차원(=32비트), 8차원(=64비트)로 유효비트 분산 저장 |
| **Q-Graceful** | 우아한 열화형 | 의미 해상도에 따라 수치·단위·스케일이 단계적으로 축약 |

## 2. 공통 헤더

```
[L][H: Quantity][B: Payload]
```

- **L**: HBBB HBBB(…); 4/8/16비트 수신 시에도 크기 대략 추정 (GEUL-SO 규격)
- **H**: Quantity 의미소 ID + 단위/권위기관 힌트 (예: SI.meter, SI.second)

### 메타데이터 (권장)
- **Unit**: "m", "kg", "s" …
- **Authority**: "SI", "ISO/IEC 80000", "NIST"
- **ConversionRef**: 변환 테이블 키(예: "in↔mm")

## 3. Q-Precise (정밀 보존형)

### 3.1 아이디어
유효비트(32/64)를 다차원으로 분산하여, 8비트 제약 채널에서도 여러 패킷으로 전송하면 원상복구 가능. 각 차원은 부분비트 블록을 담고, 재조립 규칙으로 원래 정밀 부동값을 복원.

### 3.2 형식

```yaml
[Q-Precise]
  Mode: FP32 | FP64
  DimCount: 4 (→32bit) | 8 (→64bit)
  Dim[i]: 0..255  (i=1..DimCount)   # 각 차원이 원시비트 조각을 운반
  SignScale: {sign, exponent bias, unit scale hint} # 선택적
  Unit, Authority, ConversionRef, Confidence
```

### 3.3 비트 매핑 (예시)

**FP32 모드**: IEEE754 1|8|23 비트를 4등분하여 차원 4개에 패킹
- D1: sign(1) + exponent[0..6] 일부
- D2: exponent 잔여 + mantissa[0..x]
- D3: mantissa 다음 조각
- D4: mantissa 마지막 조각

**FP64 모드**: 1|11|52 비트를 8등분하여 차원 8개에 분산

> 실제 매핑표는 드라이버(BIAS 문서)로 고정 정의 → 구현체는 그대로 직조립

### 3.4 재조립 의사코드

```python
bits = concat(unpack(D1), unpack(D2), ..., unpack(Dk))   # k=4 or 8
value = ieee754_decode(bits)                             # FP32/FP64 복원
return value
```

### 3.5 장점/주의

- **장점**: 정밀 손실 0(패킷 모두 수신 시), 8비트 경로에서도 32/64비트 보존
- **주의**: 일부 차원 손실 시 우아한 열화 규칙으로 해석(아래 5.2)

## 4. Q-Graceful (우아한 열화형)

### 4.1 아이디어
값·단위·스케일을 의미 해상도 계층으로 배치. 비트 손실/양자화 시 상위 의미로 수렴.

### 4.2 형식 (예시)

```yaml
[Q-Graceful]
  CoarseOrder: 10^k  (k∈Z)              # 대략적 스케일(예: 10^-3, 10^0, 10^3)
  Mantissa: quantized in N bits         # 남는 비트만큼 가수 근사
  Unit: "m"
  RangeHint: [min,max] (선택)
  Confidence
```

### 4.3 열화 계층 예

- **고해상도**: 1.23456 m
- **중간**: 1.23 m
- **낮음**: ≈1.2 m
- **최저**: "~1 m" 또는 "대략 미터 단위"

## 5. 혼합 운용 규칙

### 5.1 선택 기준
- **정확 계산/검증/아카이브**: Q-Precise(FP32/64) 권장
- **스트리밍/요약/휴대 디바이스**: Q-Graceful 권장

### 5.2 손실 시 폴백 (Precise → Graceful)

차원 누락/손상 발견 시:
1. 남은 차원으로 가능한 최대 정확도 복원
2. 재조립 불가하면, 부호/지수 힌트로 스케일 근사
3. 결국 Q-Graceful 해석으로 폴백 (예: "수 m 규모")

## 6. 예시

### 6.1 FP32 정밀 보존 (4D)

```yaml
QuantityPacket:
  Type: Q-Precise
  Mode: FP32
  DimCount: 4
  Dim: [173, 5, 92, 201]
  Unit: "m"
  Authority: "SI"
  ConversionRef: "in↔mm"
  Confidence: 1.0
```

### 6.2 FP64 정밀 보존 (8D)

```yaml
QuantityPacket:
  Type: Q-Precise
  Mode: FP64
  DimCount: 8
  Dim: [19, 254, 7, 33, 90, 121, 0, 44]
  Unit: "kg"
  Authority: "SI"
```

### 6.3 우아한 열화형

```yaml
QuantityPacket:
  Type: Q-Graceful
  CoarseOrder: 10^0
  Mantissa: 0.78   # 2비트 양자화 예: 0.75 근사
  Unit: "m"
  Confidence: 0.92
```

## 7. 단위 변환 (Conversion Matrix)

- 별도 테이블로 제공(예: "in→mm": 25.4), 구현체는 곱셈만 수행
- 정밀 보존형의 경우 변환 전/후 모두 FP 복원이 가능하므로, 오차 추적 메타(ulp 추정) 옵션 제공

## 8. 메타데이터/거버넌스

- **CreatedBy / Timestamps(DFC) / Version / ConfidenceScore** 메타 패킷 연동
- **AuthorityVersion** 명시(단위 정의·상수 변경 대응)
- 드라이버 문서에 **비트 매핑표(4D/8D)**와 폴백 규칙을 고정 서술

## 9. 요약

- **Q-Precise**: 4D→32비트, 8D→64비트 정밀 완전 보존(8비트 경로에서도 가능)
- **Q-Graceful**: 목적상 열화 허용 시, 스케일→가수 순으로 자연 수렴
- 표준 단위 그대로, 변환은 매트릭스. 상황에 따라 두 방식을 혼용하면 된다