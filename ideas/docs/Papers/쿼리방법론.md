# 의미정렬 아이디와 SIMD 비트마스크 N-hop 쿼리 방법론
(초안 v0.1 / 내부 설계 메모)

---

## 1. 개요

본 문서는 **의미정렬 아이디(Semantic-Aligned ID)**와  
**SIMD 비트마스크 기반 필터링**을 결합하여,

> 대규모 그래프(10억 노드/엣지 수준)에서  
> **N-hop 이웃을 고속으로 탐색**하는 쿼리 방법론

을 정리한다.

이 방식의 핵심은 다음과 같다.

1. **ID 자체가 “미리보기 메타데이터” 역할**을 하도록 설계한다.  
2. 실제 데이터(노드/엣지 구조체)를 **열어보기 전에**,  
   **상위 비트만 SIMD로 긁어 한 번에 필터링**한다.
3. 이 과정을 hop 마다 반복해도, 실제 포인터 접근/캐시 미스는 극단적으로 줄어든다.
4. 정적(위키데이터 등)과 동적(소설/작품 데이터)을 **동일한 ID 체계**로 처리하되,  
   저장소는 **이원화(static array + dynamic dictionary)** 한다.

---

## 2. Semantic ID 설계

### 2.1 32-bit Semantic ID 구조

ID는 32비트 정수로, 상위 비트에 의미를 인코딩한다.

- **MSB (1 bit)** : 저장소 구분
  - `0` = 정적 리소스 (Static Area, 예: 위키데이터)
  - `1` = 동적 리소스 (Dynamic Area, 예: 작품/세션 한정 임시 리소스)
- **Category (7 bits)** : 대분류
  - 인물, 장소, 사물, 생물, 무기, 오브젝트, 추상 개념 등
- **Index (24 bits)** : 카테고리 내 고유 번호

수식으로 표현하면:

\[
\text{ID} = [\text{Flag (1bit)}] \parallel [\text{Category (7bit)}] \parallel [\text{Index (24bit)}]
\]

- 예시:
  - `0x01_000001` : 정적 리소스, Category=1(예: 인물), Index=1
  - `0x81_000005` : 동적 리소스, Category=1(예: 무기), Index=5  
    (MSB=1 → 동적, Category=1 → 무기 라는 의미)

### 2.2 의미정렬의 목적

의미정렬 ID의 목적은:

1. **ID만 보고도 타입/스토리지/대분류를 빠르게 판단**하기
2. **SIMD 기반 비트마스크 필터에 최적화된 레이아웃**을 제공하기
3. 포인터 접근이나 딕셔너리 조회 전에 **조기 차단(Early Reject)** 을 수행하기

---

## 3. 저장소 구조: Static + Dynamic 듀얼 스토리지

### 3.1 Static Area (정적 영역)

- 예: 위키데이터를 GEUL 온톨로지로 변환한 리소스
- 특성:
  - 거의 변경되지 않는 **불변 데이터**
  - ID의 `Flag=0`인 리소스들이 여기에 위치
- 저장 방식:
  - **배열(또는 BLOB) 기반 연속 메모리**
  - `Index`를 이용해 곧바로 오프셋 계산 가능

→ 장점:  
**배열 인덱싱만으로 O(1) 접근**, 캐시 친화적, SIMD 로딩에 유리.

---

### 3.2 Dynamic Area (동적 영역)

- 예: 소설 작품 내에서만 존재하는 인물/아이템/임시 리소스
- 특성:
  - 수시로 추가/변경/삭제 가능
  - ID의 `Flag=1`인 리소스들이 여기에 위치
- 저장 방식:
  - **Dictionary (Hash Map)**: `Key = Semantic ID`, `Value = Pointer`
  - `Value`는 힙/풀에 있는 실제 데이터 구조체/스트림 주소

→ 장점:  
유연한 생성/삭제, 프로젝트 별 샤딩 용이.  
하지만 무작위 메모리 접근이 많아질 수 있음 → 이것을 **ID 기반 Early Reject + SIMD 필터**로 상쇄.

---

## 4. 엣지/그래프 데이터 모델

### 4.1 노드와 엣지

- **노드(Node)**: Entity (인물, 장소, 사물, 개념 등), 각각 Semantic ID를 가짐.
- **엣지(Edge)**: 두 노드 간 관계/트리플. 예:
  - (주어: A) –[predicate=소지품]→ (목적어: B)
  - (검) –[제작자]→ (대장장이)

### 4.2 엣지 스트림 구조

각 노드는 자신의 **엣지 스트림**을 가진다.

- 구조 예:
  - `Edges(A) = [ (predID1, targetID1, meta1), (predID2, targetID2, meta2), ... ]`
- 메모리 레이아웃:
  - 가능한 한 **연속 배열** 형태로 저장하여,  
    SIMD 로딩에 최적화.

여기서 `targetID`는 그대로 32-bit Semantic ID이며,  
SIMD 필터 대상이 된다.

---

## 5. SIMD 비트마스크 필터링

### 5.1 아이디어 핵심

> **“ID 10억 건이 있더라도, 상위 16비트만 32개씩 SIMD 레지스터에 올려  
> 비트마스크 비교를 2~3번 하면,  
> 실제 데이터(포인터)를 따라가야 하는 후보는 극단적으로 줄일 수 있다.”**

즉,

1. 상위 비트(Flag+Category 등)를 기준으로  
2. 한 번에 수십 개의 ID를 비교하고  
3. 조건 불일치 항목은 **데이터 구조를 보기도 전에 버린다.**

### 5.2 1차 필터: 저장소/대분류 기반 필터

예: 생물형(Creature) 동적 리소스만 찾는 쿼리

- 쿼리 조건:
  - `Flag = 1 (동적)`
  - `Category = 0x03 (생물)`
- 구현:
  1. ID 배열을 16/32개 단위로 SIMD 레지스터에 로드
  2. 상위 16비트 추출 (`ID >> 16`)
  3. 상수 패턴(예: `0x83xx`)과 벡터 비교
  4. 결과로 **비트마스크(mask)** 얻기 →  
     - 1인 비트: 후보 유지  
     - 0인 비트: 즉시 Drop (Value/포인터 접근 없음)

→ 메모리 접근은 ID 배열에 대한 선형 읽기만 수행,  
실제 구조체/딕셔너리 접근은 mask에서 살아남은 일부만 수행.

### 5.3 2차 필터: 세부 타입/Scene/상태 기반 필터

1차 필터 후 살아남은 ID에 대해,  
추가적인 조건(예: Scene 범위, 상태 플래그 등)을 비트 단위로 인코딩해두었다면,

- 동일하게 SIMD 비교 → 또 한 번 마스크 축소.

예시:

- 상위 8비트: 카테고리
- 다음 4~8비트: 세부 타입/씬 샤드 등

이렇게 구성하면 **비트마스크 연산 2회 정도로**:

1. 카테고리/플래그 기반 1차 축소
2. 타입/씬/버전 기반 2차 축소

까지 수행 가능.

---

## 6. N-hop 쿼리 절차

### 6.1 문제 정의

- 입력:
  - 시작 노드 집합 S (ID 리스트)
  - hop 수 N
  - 엣지 타입/카테고리 조건 (예: “생물형 인물만”, “무기와 관련된 엣지만” 등)
- 목표:
  - S에서 시작해 **N-hop 이내 도달 가능한 노드 집합**을  
    가능한 한 빠르게 구한다.

### 6.2 1-hop 쿼리 기본 절차

1. **시작 노드 S의 엣지 스트림 로딩**
   - 각 노드에 대해 `Edges(node)`를 연속 블록 단위로 확보
2. **타겟 ID 배열 벡터 로딩**
   - `targetID[]`를 SIMD 레지스터로 16/32개씩 로딩
3. **1차 SIMD 필터 (상위 16비트)**
   - Flag / Category 기반 필터
   - 조건 불일치 ID는 즉시 Drop
4. **2차 SIMD 필터 (추가 조건)**
   - 세부 타입, Scene, 상태 비트 등
   - 다시 마스크 적용 → 최종 후보 ID 집합 H1 획득
5. **H1에 대해서만 실제 데이터 접근 / 딕셔너리 조회 수행**

### 6.3 N-hop(예: 3-hop) 확장

3-hop 쿼리 예:

- 1-hop: S → H1
- 2-hop: H1 → H2
- 3-hop: H2 → H3

모든 hop에서 동일 패턴:

1. 이전 hop 결과 집합(Hi)에서 엣지 스트림을 모은다.
2. 타겟 ID들을 다시 ID 배열로 만들고,
3. SIMD 비트마스크 필터를 1~2회 돌린다.
4. 살아남은 ID들을 다음 hop의 시작 집합으로 사용.

**중요한 점:**

- 각 hop마다 “후보 수”는 필터를 거치며 폭축된다.
- SIMD로 연산하는 부분은 **순전히 정수 연산 + 비교 + 마스크**일 뿐이라,
  실제 병목은 “얼마나 많이 포인터를 따라가는가”인데,  
  의미정렬 ID + 필터링 설계로 이 횟수를 극단적으로 줄인다.

---

## 7. 위키데이터 → GEUL 변환과의 결합

### 7.1 정적 지식(위키데이터)의 GEUL화

- 위키데이터의 Q/P/값 트리플을 GEUL 온톨로지에 맞게 변환:
  - Q(엔티티) → 노드 (Semantic ID 부여)
  - P(프로퍼티) + 값 → 엣지(관계)로 변환
- 변환된 결과는 **Static Area**에 저장:
  - `Flag=0`인 ID 영역
  - 정적 그래프(세계 지식)로 동작

### 7.2 동적 세계(작품 설정)와의 통합

- 작품 내부 설정/인물/아이템/사건은 **동적 리소스**, `Flag=1` 영역으로 할당.
- 위키 기반 정적 세계와 작품 기반 동적 세계를 **하나의 그래프 상에서** 다룬다.

예를 들어:

- 정적: 실제 역사 인물/국가/전쟁
- 동적: 대체역사 분기점 이후 새로 생긴 인물/국가/사건

쿼리 관점에서는:

- “3-hop 이내에서 A와 연결된 모든 인물(정적+동적)”  
  같은 요청을 **한 번의 N-hop 쿼리로 처리**할 수 있다.

---

## 8. 장점 정리

1. **극단적인 범용성 + 성능**
   - N-hop 그래프 쿼리를 **일반적인 그래프DB보다 훨씬 CPU·캐시 친화적으로** 수행.
   - 특히 “타입·카테고리 기반 질의”에서 효과가 극대화된다.

2. **정적·동적 데이터의 자연스러운 결합**
   - 위키데이터(정적)와 작품 설정(동적)을 같은 ID 규칙으로 다루면서,
   - 스토리지/접근 방식은 분리하여 성능 최적화.

3. **월드 모델/스토리 엔진에 특화된 쿼리**
   - “팔 잘린 인물만”, “특정 무기와 3-hop 내에서 연결된 사건/인물만” 등  
     서사 전용 쿼리를 매우 빠르게 실행 가능.

4. **LLM에 의존하지 않는 조회 레이어**
   - 설정/세계/연결관계 등은 **DB 레이어에서 직접 쿼리**,  
   - LLM은 그 결과를 “텍스트로 렌더링하는 역할”에 집중.

---

## 9. 한 줄 요약

> **의미정렬 아이디 + SIMD 비트마스크 N-hop 쿼리**는  
> “ID만 보고 미리 거를 건 다 걸러버린 다음,  
> 진짜 데이터는 필요한 것만 최소한으로 여는”  
> **스토리/월드 모델용 초고속 그래프 엔진 설계 방법론**이다.
```0
